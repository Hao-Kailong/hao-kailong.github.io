<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hold the Torch</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haokailong.top/"/>
  <updated>2021-04-06T10:57:30.201Z</updated>
  <id>http://haokailong.top/</id>
  
  <author>
    <name>dinosaur</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中头文件&lt;bits/stdc++.h&gt;</title>
    <link href="http://haokailong.top/2021/04/06/C-%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6-bits-stdc-h/"/>
    <id>http://haokailong.top/2021/04/06/C-中头文件-bits-stdc-h/</id>
    <published>2021-04-06T10:48:08.000Z</published>
    <updated>2021-04-06T10:57:30.201Z</updated>
    
    <content type="html"><![CDATA[<p>在刷题的过程中，发现有<code>&lt;bits/stdc++.h&gt;</code>这样一个头文件。</p><p>发现它是部分C++中支持的一个几乎万能的头文件，包含所有的可用到的C++库函数，如<istream>/<ostream>/<stack>/<queue>.</queue></stack></ostream></istream></p><p>该头文件的详细内容如下</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ includes used for precompiling -*- C++ -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copyright (C) 2003-2013 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span></span><br><span class="line"><span class="comment">// software; you can redistribute it and/or modify it under the</span></span><br><span class="line"><span class="comment">// terms of the GNU General Public License as published by the</span></span><br><span class="line"><span class="comment">// Free Software Foundation; either version 3, or (at your option)</span></span><br><span class="line"><span class="comment">// any later version.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span></span><br><span class="line"><span class="comment">// permissions described in the GCC Runtime Library Exception, version</span></span><br><span class="line"><span class="comment">// 3.1, as published by the Free Software Foundation.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License and</span></span><br><span class="line"><span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span></span><br><span class="line"><span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span></span><br><span class="line"><span class="comment">// &lt;Licenses - GNU Project - Free Software Foundation&gt;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @file stdc++.h</span></span><br><span class="line"><span class="comment"> *  This is an implementation file for a precompiled header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 17.4.1.2 Headers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GLIBCXX_NO_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ciso646&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csetjmp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ccomplex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfenv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdalign&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctgmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cwchar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cwctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;scoped_allocator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeindex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="bits-stdc-h的缺点"><a href="#bits-stdc-h的缺点" class="headerlink" title="bits/stdc++.h的缺点"></a><code>bits/stdc++.h</code>的缺点</h1><ul><li>bits/stdc++.h 不是GNU C++库的标准头文件，所以如果你在一些编译器（除了GCC）上编译你的代码，可能会失败，比如MSVC没有这个头文件。</li><li>使用它会包含很多不必要的东西，并且会增加编译时间</li><li>这个头文件不是C++标准的一部分，所以是不可移植的，应该尽量避免。</li><li>尽管标准中有一些通用的头文件，但还是应该避免使用它来代替特定的头文件，因为编译器在每次编译转换单元时都实际地读取并解析每个包含的头文件(包括递归包含的头文件)。</li></ul><h1 id="bits-stdc-h的优点"><a href="#bits-stdc-h的优点" class="headerlink" title="bits/stdc++.h的优点"></a><code>bits/stdc++.h</code>的优点</h1><ul><li>在比赛中,使用这个文件是一个好主意,当你想减少时间浪费在做选择的时候;特别是当你的排名对时间很敏感的时候。</li><li>这还减少了编写所有必要头文件的所有杂务。</li><li>你不必为使用的每个函数都记住GNU c++的所有STL。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在刷题的过程中，发现有&lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt;这样一个头文件。&lt;/p&gt;
&lt;p&gt;发现它是部分C++中支持的一个几乎万能的头文件，包含所有的可用到的C++库函数，如&lt;istream&gt;/&lt;ostream&gt;/&lt;stack&gt;/&lt;queue&gt;.&lt;/queue&gt;&lt;/stack&gt;&lt;/ostream&gt;&lt;/istream&gt;&lt;/p&gt;
&lt;p&gt;该头文件的详细内容如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://haokailong.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="STL" scheme="http://haokailong.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>笔试经验总结</title>
    <link href="http://haokailong.top/2021/04/04/%E7%AC%94%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://haokailong.top/2021/04/04/笔试经验总结/</id>
    <published>2021-04-04T07:24:50.000Z</published>
    <updated>2021-04-04T07:35:41.130Z</updated>
    
    <content type="html"><![CDATA[<p>已经有过几次笔试的经验了，也经历了不少的失败和挫折，做一个总结：</p><ol><li>ACM格式比LeetCode要难，因为要自己处理输入输出，需要保证处理的正确而且速度快；另外，需要自己考虑到所有的corner case。<strong>在LeetCode上会提示测试通不过的样例，不要看！</strong>这是一个很不好的习惯，会形成依赖。要在脑海中自己把问题考虑周全。</li><li>要先把题目看一遍，<strong>如果某个题短时间内不能有一个</strong><font color="orange"><strong>清晰直接</strong></font><strong>的思路，多半是自己搞错了</strong>。不要浪费时间！</li><li>要熟练掌握C++中的STL和常用函数。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已经有过几次笔试的经验了，也经历了不少的失败和挫折，做一个总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ACM格式比LeetCode要难，因为要自己处理输入输出，需要保证处理的正确而且速度快；另外，需要自己考虑到所有的corner case。&lt;strong&gt;在LeetCode上会提示测
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="ACM" scheme="http://haokailong.top/tags/ACM/"/>
    
      <category term="OJ" scheme="http://haokailong.top/tags/OJ/"/>
    
      <category term="LeetCode" scheme="http://haokailong.top/tags/LeetCode/"/>
    
      <category term="Interview" scheme="http://haokailong.top/tags/Interview/"/>
    
      <category term="春招" scheme="http://haokailong.top/tags/%E6%98%A5%E6%8B%9B/"/>
    
      <category term="笔试" scheme="http://haokailong.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>int long 和 long long 的区别</title>
    <link href="http://haokailong.top/2021/04/03/int-long-%E5%92%8C-long-long-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://haokailong.top/2021/04/03/int-long-和-long-long-的区别/</id>
    <published>2021-04-03T08:56:35.000Z</published>
    <updated>2021-04-03T09:11:03.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>(4个字节，32位)</p><p>unsigned int: 0 ~ 4294967295</p><p>int: -2147483648 ~ 2147483647</p><h3 id="int32"><a href="#int32" class="headerlink" title="_int32"></a>_int32</h3><p>(4个字节，32位)<br>unsigned _int32: 0～4294967295<br>_int32: -2147483648 ~ 2147483647</p><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>(4个字节，32位)<br>unsigned long: 0～4294967295<br>long: -2147483648～2147483647</p><h3 id="long-long"><a href="#long-long" class="headerlink" title="long long"></a>long long</h3><p>(8个字节，64位)<br>unsigned long long：0~1844674407370955161<br>long long：-9223372036854775808~9223372036854775807</p><a id="more"></a><h3 id="int64"><a href="#int64" class="headerlink" title="_int64"></a>_int64</h3><p>(8个字节，64位)<br>unsigned _int64：0~18446744073709551615<br>_int64：-9223372036854775808~9223372036854775807</p><h2 id="为什么有long和long-long"><a href="#为什么有long和long-long" class="headerlink" title="为什么有long和long long?"></a>为什么有long和long long?</h2><ul><li>早期的操作系统是16位系统</li></ul><p>int用两个字节表示，范围是-32768 ~ 32767</p><p>long用四个字节表示，范围是-2147483648 ~ 2147483647</p><ul><li>后来发展到32位操作系统</li></ul><p>int用四个字节表示，与long相同</p><ul><li>目前操作系统已经发展到64位操作系统，<strong>但因程序编译工艺的不同，两者表现出不同的差别</strong>:</li></ul><p>32位编译系统：int占四字节，与long相同</p><p>64位编译系统：int占四字节，long占八字节，long数据范围变为：$-2^{63} \sim 2^{63}-1$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;h3 id=&quot;int&quot;&gt;&lt;a href=&quot;#int&quot; class=&quot;headerlink&quot; title=&quot;int&quot;&gt;&lt;/a&gt;int&lt;/h3&gt;&lt;p&gt;(4个字节，32位)&lt;/p&gt;
&lt;p&gt;unsigned int: 0 ~ 4294967295&lt;/p&gt;
&lt;p&gt;int: -2147483648 ~ 2147483647&lt;/p&gt;
&lt;h3 id=&quot;int32&quot;&gt;&lt;a href=&quot;#int32&quot; class=&quot;headerlink&quot; title=&quot;_int32&quot;&gt;&lt;/a&gt;_int32&lt;/h3&gt;&lt;p&gt;(4个字节，32位)&lt;br&gt;unsigned _int32: 0～4294967295&lt;br&gt;_int32: -2147483648 ~ 2147483647&lt;/p&gt;
&lt;h3 id=&quot;long&quot;&gt;&lt;a href=&quot;#long&quot; class=&quot;headerlink&quot; title=&quot;long&quot;&gt;&lt;/a&gt;long&lt;/h3&gt;&lt;p&gt;(4个字节，32位)&lt;br&gt;unsigned long: 0～4294967295&lt;br&gt;long: -2147483648～2147483647&lt;/p&gt;
&lt;h3 id=&quot;long-long&quot;&gt;&lt;a href=&quot;#long-long&quot; class=&quot;headerlink&quot; title=&quot;long long&quot;&gt;&lt;/a&gt;long long&lt;/h3&gt;&lt;p&gt;(8个字节，64位)&lt;br&gt;unsigned long long：0~1844674407370955161&lt;br&gt;long long：-9223372036854775808~9223372036854775807&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://haokailong.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="int" scheme="http://haokailong.top/tags/int/"/>
    
      <category term="long" scheme="http://haokailong.top/tags/long/"/>
    
      <category term="long long" scheme="http://haokailong.top/tags/long-long/"/>
    
      <category term="整型" scheme="http://haokailong.top/tags/%E6%95%B4%E5%9E%8B/"/>
    
      <category term="integer" scheme="http://haokailong.top/tags/integer/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://haokailong.top/2021/04/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://haokailong.top/2021/04/01/快速排序/</id>
    <published>2021-04-01T12:10:48.000Z</published>
    <updated>2021-04-01T12:52:42.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、算法思想"><a href="#一、算法思想" class="headerlink" title="一、算法思想"></a>一、算法思想</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h1 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h1><p>2.1、设置两个变量 low、high，<strong>排序开始时：low=0，high=size-1。</strong><br>2.2、整个数组找基准正确位置，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面</p><ul><li>默认数组的第一个数为基准数据，赋值给key，即key=array[low]。</li><li>因为默认数组的第一个数为基准，<strong>所以从后面开始向前搜索（high—）</strong>，找到第一个<strong>小于</strong>key的array[high]，就将 array[high] 赋给 array[low]，即 array[low] = array[high]。（循环条件是 array[high] &gt;= key；结束时 array[high] &lt; key）</li><li>此时从前面开始向后搜索（low++），找到第一个<strong>大于</strong>key的array[low]，就将 array[low] 赋给 array[high]，即 array[high] = array[low]。（循环条件是 array[low] &lt;= key；结束时 array[low] &gt; key）</li><li>循环 2-3 步骤，直到 low=high，该位置就是基准位置。</li><li>把基准数据赋给当前位置。</li></ul><p>2.3、第一趟找到的基准位置，作为下一趟的分界点。<br>2.4、递归调用（recursive）分界点前和分界点后的子数组排序，重复2.2、2.3、2.4的步骤。<br>2.5、最终就会得到排序好的数组。</p><a id="more"></a><h1 id="三、稳定性"><a href="#三、稳定性" class="headerlink" title="三、稳定性"></a>三、稳定性</h1><p>快速排序算法是不稳定的。也就是说，相同大小的元素可能在排序前后位置有所调换。</p><p>可以将排序算法实现为稳定算法，但是可能会带来性能的下降。</p><blockquote><p>参考CSDN博客：</p><p><a href="https://blog.csdn.net/gaoxueyi551/article/details/89413936" target="_blank" rel="noopener">https://blog.csdn.net/gaoxueyi551/article/details/89413936</a></p></blockquote><h1 id="四、C-实现"><a href="#四、C-实现" class="headerlink" title="四、C++实现"></a>四、C++实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= e)  <span class="comment">// 终止条件 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> pivot = a[s];</span><br><span class="line"><span class="keyword">int</span> high = e;</span><br><span class="line"><span class="keyword">int</span> low = s;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= pivot) --high;</span><br><span class="line">a[low] = a[high];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= pivot) ++low;</span><br><span class="line">a[high] = a[low];</span><br><span class="line">&#125;</span><br><span class="line">a[low] = pivot;  <span class="comment">// low == high</span></span><br><span class="line">quicksort(a, s, low - <span class="number">1</span>);</span><br><span class="line">quicksort(a, low + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">quicksort(a, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、算法思想&quot;&gt;&lt;a href=&quot;#一、算法思想&quot; class=&quot;headerlink&quot; title=&quot;一、算法思想&quot;&gt;&lt;/a&gt;一、算法思想&lt;/h1&gt;&lt;p&gt;快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。&lt;/p&gt;
&lt;h1 id=&quot;二、实现原理&quot;&gt;&lt;a href=&quot;#二、实现原理&quot; class=&quot;headerlink&quot; title=&quot;二、实现原理&quot;&gt;&lt;/a&gt;二、实现原理&lt;/h1&gt;&lt;p&gt;2.1、设置两个变量 low、high，&lt;strong&gt;排序开始时：low=0，high=size-1。&lt;/strong&gt;&lt;br&gt;2.2、整个数组找基准正确位置，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认数组的第一个数为基准数据，赋值给key，即key=array[low]。&lt;/li&gt;
&lt;li&gt;因为默认数组的第一个数为基准，&lt;strong&gt;所以从后面开始向前搜索（high—）&lt;/strong&gt;，找到第一个&lt;strong&gt;小于&lt;/strong&gt;key的array[high]，就将 array[high] 赋给 array[low]，即 array[low] = array[high]。（循环条件是 array[high] &amp;gt;= key；结束时 array[high] &amp;lt; key）&lt;/li&gt;
&lt;li&gt;此时从前面开始向后搜索（low++），找到第一个&lt;strong&gt;大于&lt;/strong&gt;key的array[low]，就将 array[low] 赋给 array[high]，即 array[high] = array[low]。（循环条件是 array[low] &amp;lt;= key；结束时 array[low] &amp;gt; key）&lt;/li&gt;
&lt;li&gt;循环 2-3 步骤，直到 low=high，该位置就是基准位置。&lt;/li&gt;
&lt;li&gt;把基准数据赋给当前位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.3、第一趟找到的基准位置，作为下一趟的分界点。&lt;br&gt;2.4、递归调用（recursive）分界点前和分界点后的子数组排序，重复2.2、2.3、2.4的步骤。&lt;br&gt;2.5、最终就会得到排序好的数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="sort" scheme="http://haokailong.top/tags/sort/"/>
    
      <category term="quick sort" scheme="http://haokailong.top/tags/quick-sort/"/>
    
      <category term="algorithm" scheme="http://haokailong.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>文件路径分割</title>
    <link href="http://haokailong.top/2021/03/30/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%88%86%E5%89%B2/"/>
    <id>http://haokailong.top/2021/03/30/文件路径分割/</id>
    <published>2021-03-30T05:11:58.000Z</published>
    <updated>2021-03-30T05:13:58.676Z</updated>
    
    <content type="html"><![CDATA[<p>直接垒代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_path = <span class="string">"E:/tt/abc.py"</span></span><br><span class="line">filepath,fullflname = os.path.split(file_path)</span><br><span class="line">fname,ext = os.path.splitext(fullflname)</span><br></pre></td></tr></table></figure><p>运行结果:<br>filepath为文件的目录,即E:/tt<br>fullflname为文件名的全名，即abc.py<br>fname为文件的名字,即abc<br>ext为文件的扩展名,即.py</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直接垒代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="python" scheme="http://haokailong.top/tags/python/"/>
    
      <category term="os" scheme="http://haokailong.top/tags/os/"/>
    
      <category term="split" scheme="http://haokailong.top/tags/split/"/>
    
  </entry>
  
  <entry>
    <title>python遍历文件夹获取文件</title>
    <link href="http://haokailong.top/2021/03/29/python%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6/"/>
    <id>http://haokailong.top/2021/03/29/python遍历文件夹获取文件/</id>
    <published>2021-03-29T15:28:45.000Z</published>
    <updated>2021-03-30T04:43:47.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-手写递归"><a href="#1-手写递归" class="headerlink" title="1. 手写递归"></a>1. 手写递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getallfile</span><span class="params">(path)</span>:</span></span><br><span class="line">    allfilelist=os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> allfilelist:</span><br><span class="line">        filepath=os.path.join(path,file)</span><br><span class="line">        <span class="comment">#判断是不是文件夹</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</span><br><span class="line">            getallfile(filepath)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        allfile.append(filepath)</span><br><span class="line">    <span class="keyword">return</span> allfile</span><br></pre></td></tr></table></figure><h2 id="2-os-walk"><a href="#2-os-walk" class="headerlink" title="2. os.walk()"></a>2. os.walk()</h2><p><code>os.walk(top, topdown=True, οnerrοr=None, followlinks=False)</code><br>返回一个3个元素的元祖，(dirpath, dirnames, filenames),<br>dirpath：要列出指定目录的路径<br>dirnames：目录下的所有文件夹<br>filenames：目录下的所有文件</p><a id="more"></a><p>参数一：top – 根目录下的每一个文件夹(包含它自己), 产生3-元组 (dirpath, dirnames, filenames)【文件夹路径, 文件夹名字, 文件名】。</p><p>参数二：topdown –可选，为True或者没有指定, 一个目录的的3-元组将比它的任何子文件夹的3-元组先产生 (目录自上而下)。如果topdown为 False, 一个目录的3-元组将比它的任何子文件夹的3-元组后产生 (目录自下而上)。</p><p>参数三：onerror – 可选，是一个函数; 它调用时有一个参数, 一个OSError实例。报告这错误后，继续walk,或者抛出exception终止walk。</p><p>参数四：followlinks – 设置为 true，则通过软链接访问目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getallfiles</span><span class="params">(path)</span>:</span></span><br><span class="line">    allfile=[]</span><br><span class="line">    <span class="keyword">for</span> dirpath,dirnames,filenames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> dirnames:</span><br><span class="line">            allfile.append(os.path.join(dirpath,dir))</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> filenames:</span><br><span class="line">            allfile.append(os.path.join(dirpath, name))</span><br><span class="line">    <span class="keyword">return</span> allfile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-手写递归&quot;&gt;&lt;a href=&quot;#1-手写递归&quot; class=&quot;headerlink&quot; title=&quot;1. 手写递归&quot;&gt;&lt;/a&gt;1. 手写递归&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getallfile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(path)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    allfilelist=os.listdir(path)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; file &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; allfilelist:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filepath=os.path.join(path,file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#判断是不是文件夹&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; os.path.isdir(filepath):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            getallfile(filepath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	allfile.append(filepath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; allfile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2-os-walk&quot;&gt;&lt;a href=&quot;#2-os-walk&quot; class=&quot;headerlink&quot; title=&quot;2. os.walk()&quot;&gt;&lt;/a&gt;2. os.walk()&lt;/h2&gt;&lt;p&gt;&lt;code&gt;os.walk(top, topdown=True, οnerrοr=None, followlinks=False)&lt;/code&gt;&lt;br&gt;返回一个3个元素的元祖，(dirpath, dirnames, filenames),&lt;br&gt;dirpath：要列出指定目录的路径&lt;br&gt;dirnames：目录下的所有文件夹&lt;br&gt;filenames：目录下的所有文件&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="python" scheme="http://haokailong.top/tags/python/"/>
    
      <category term="walk" scheme="http://haokailong.top/tags/walk/"/>
    
      <category term="os" scheme="http://haokailong.top/tags/os/"/>
    
      <category term="recursive" scheme="http://haokailong.top/tags/recursive/"/>
    
  </entry>
  
  <entry>
    <title>直观理解线性变换</title>
    <link href="http://haokailong.top/2021/03/29/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
    <id>http://haokailong.top/2021/03/29/直观理解线性变换/</id>
    <published>2021-03-29T12:41:54.000Z</published>
    <updated>2021-03-29T12:47:03.315Z</updated>
    
    <content type="html"><![CDATA[<p>直观一点理解，线性变换是一种运动，即让每一个输入向量都<strong>移动</strong>到对应输出向量的位置。</p><p>那么这样，线性变换这个关于向量的移动，就可以直观地变成了坐标系上点的运动。</p><p>简单来说，线性变换可以看作是坐标系“<strong>整体、均匀</strong>”的变换。</p><p>更详细地参见以下这个视频：</p><p><a href="https://www.bilibili.com/video/av6043439" target="_blank" rel="noopener">https://www.bilibili.com/video/av6043439</a></p><p>而<strong>仿射变换 (Affine Transformation)</strong>会改变原点的位置，而<strong>线性变换 (Linear Transformation)</strong>不改变原点的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直观一点理解，线性变换是一种运动，即让每一个输入向量都&lt;strong&gt;移动&lt;/strong&gt;到对应输出向量的位置。&lt;/p&gt;
&lt;p&gt;那么这样，线性变换这个关于向量的移动，就可以直观地变成了坐标系上点的运动。&lt;/p&gt;
&lt;p&gt;简单来说，线性变换可以看作是坐标系“&lt;strong&gt;整
      
    
    </summary>
    
    
      <category term="Mathmatic" scheme="http://haokailong.top/categories/Mathmatic/"/>
    
    
      <category term="Linear Transformation" scheme="http://haokailong.top/tags/Linear-Transformation/"/>
    
      <category term="Affine Transformation" scheme="http://haokailong.top/tags/Affine-Transformation/"/>
    
      <category term="线性变换" scheme="http://haokailong.top/tags/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>SMOTE上采样方法</title>
    <link href="http://haokailong.top/2021/03/29/SMOTE%E4%B8%8A%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95/"/>
    <id>http://haokailong.top/2021/03/29/SMOTE上采样方法/</id>
    <published>2021-03-29T11:17:23.000Z</published>
    <updated>2021-03-29T11:52:59.801Z</updated>
    
    <content type="html"><![CDATA[<p>SMOTE or <strong>Synthetic Minority Oversampling Technique</strong></p><p>经典的上采样方法是直接将少数类别的样本重复若干次。但是这种方法没有带来新的信息。</p><blockquote><p>SMOTE works by utilizing a <strong>k-nearest neighbor</strong> algorithm to create synthetic data. SMOTE first start by choosing random data from the minority class, then k-nearest neighbors from the data are set. Synthetic data would then made between the random data and the randomly selected k-nearest neighbor. Let me show you the example below.</p></blockquote><h2 id="1-SMOTE使用"><a href="#1-SMOTE使用" class="headerlink" title="1. SMOTE使用"></a>1. SMOTE使用</h2><p>SMOTE适用于特征值为连续值而不是离散值。这样才可以进行插值，产生新的训练数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborns <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment">#I read the csv churn data into variable called df. Here I would only use two continuous features CreditScore and Age with the target Exited</span></span><br><span class="line">df_example = df[[<span class="string">'CreditScore'</span>, <span class="string">'Age'</span>, <span class="string">'Exited'</span>]]</span><br><span class="line">sns.scatterplot(data = df, x =<span class="string">'CreditScore'</span>, y = <span class="string">'Age'</span>, hue = <span class="string">'Exited'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/max/487/1*53v1-PbF5uCiSZnLKDJZ5w.png" alt></p><p>然后使用SMOTE上采样，查看采样之后的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U imbalanced-learn</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Importing SMOTE</span></span><br><span class="line"><span class="keyword">from</span> imblearn.over_sampling <span class="keyword">import</span> SMOTE</span><br><span class="line"><span class="comment">#Oversampling the data</span></span><br><span class="line">smote = SMOTE(random_state = <span class="number">101</span>)</span><br><span class="line">X, y = smote.fit_resample(df[[<span class="string">'CreditScore'</span>, <span class="string">'Age'</span>]], df[<span class="string">'Exited'</span>])</span><br><span class="line"><span class="comment">#Creating a new Oversampling Data Frame</span></span><br><span class="line">df_oversampler = pd.DataFrame(X, columns = [<span class="string">'CreditScore'</span>, <span class="string">'Age'</span>])</span><br><span class="line">df_oversampler[<span class="string">'Exited'</span>]</span><br><span class="line">sns.countplot(df_oversampler[<span class="string">'Exited'</span>])</span><br><span class="line">sns.scatterplot(data = df_oversampler, x =<span class="string">'CreditScore'</span>, y = <span class="string">'Age'</span>, hue = <span class="string">'Exited'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://miro.medium.com/max/498/1*BVlx5Mo-1L3pbnKCT_N9Nw.png" alt></p><h2 id="2-SMOTE原理"><a href="#2-SMOTE原理" class="headerlink" title="2. SMOTE原理"></a>2. SMOTE原理</h2><p>算法流程：</p><ol><li>对于少数类中每一个样本$x$，以欧氏距离为标准计算它到少数类样本集$S_{min}$所有样本的距离，得到其k近邻。</li><li>根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本$x$，从其k近邻中随机选择若干个样本，假设选择的近邻为$x_n$</li><li>对于每一个随机选出的近邻$x_n$，分别与原样本按照如下的公式构建新的样本</li></ol><script type="math/tex; mode=display">x_{new} = x + \mathrm{rand}（0,1）*|x - x_n|</script><p>很直白很容易理解，就是用某个样本与其近邻做插值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SMOTE or &lt;strong&gt;Synthetic Minority Oversampling Technique&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经典的上采样方法是直接将少数类别的样本重复若干次。但是这种方法没有带来新的信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SMOTE works by utilizing a &lt;strong&gt;k-nearest neighbor&lt;/strong&gt; algorithm to create synthetic data. SMOTE first start by choosing random data from the minority class, then k-nearest neighbors from the data are set. Synthetic data would then made between the random data and the randomly selected k-nearest neighbor. Let me show you the example below.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-SMOTE使用&quot;&gt;&lt;a href=&quot;#1-SMOTE使用&quot; class=&quot;headerlink&quot; title=&quot;1. SMOTE使用&quot;&gt;&lt;/a&gt;1. SMOTE使用&lt;/h2&gt;&lt;p&gt;SMOTE适用于特征值为连续值而不是离散值。这样才可以进行插值，产生新的训练数据。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; seaborns &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; sns&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#I read the csv churn data into variable called df. Here I would only use two continuous features CreditScore and Age with the target Exited&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df_example = df[[&lt;span class=&quot;string&quot;&gt;&#39;CreditScore&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Exited&#39;&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sns.scatterplot(data = df, x =&lt;span class=&quot;string&quot;&gt;&#39;CreditScore&#39;&lt;/span&gt;, y = &lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;, hue = &lt;span class=&quot;string&quot;&gt;&#39;Exited&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/487/1*53v1-PbF5uCiSZnLKDJZ5w.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;然后使用SMOTE上采样，查看采样之后的结果：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install -U imbalanced-learn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Importing SMOTE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; imblearn.over_sampling &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; SMOTE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Oversampling the data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;smote = SMOTE(random_state = &lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X, y = smote.fit_resample(df[[&lt;span class=&quot;string&quot;&gt;&#39;CreditScore&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;]], df[&lt;span class=&quot;string&quot;&gt;&#39;Exited&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Creating a new Oversampling Data Frame&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df_oversampler = pd.DataFrame(X, columns = [&lt;span class=&quot;string&quot;&gt;&#39;CreditScore&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df_oversampler[&lt;span class=&quot;string&quot;&gt;&#39;Exited&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sns.countplot(df_oversampler[&lt;span class=&quot;string&quot;&gt;&#39;Exited&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sns.scatterplot(data = df_oversampler, x =&lt;span class=&quot;string&quot;&gt;&#39;CreditScore&#39;&lt;/span&gt;, y = &lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;, hue = &lt;span class=&quot;string&quot;&gt;&#39;Exited&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://haokailong.top/categories/Machine-Learning/"/>
    
    
      <category term="SMOTE" scheme="http://haokailong.top/tags/SMOTE/"/>
    
      <category term="oversampling" scheme="http://haokailong.top/tags/oversampling/"/>
    
  </entry>
  
  <entry>
    <title>通俗理解困惑度(Perplexity)</title>
    <link href="http://haokailong.top/2021/03/29/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E5%9B%B0%E6%83%91%E5%BA%A6-Perplexity/"/>
    <id>http://haokailong.top/2021/03/29/通俗理解困惑度-Perplexity/</id>
    <published>2021-03-29T06:05:22.000Z</published>
    <updated>2021-03-29T06:24:31.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、语言模型"><a href="#一、语言模型" class="headerlink" title="一、语言模型"></a><strong>一、语言模型</strong></h2><p>本文尽量通俗解释一下困惑度的概念。既然题目中写了是用来评价语言模型的好坏，那么首先来看一下语言模型：</p><p><strong>简单地说，语言模型就是用来计算一个句子的概率的模型，也就是判断一句话是否是人话的概率？</strong></p><p>那么如何计算一个句子的概率呢？给定句子（词语序列）</p><p>$S= W_1, …, W_k$</p><p>它的概率可以表示为：</p><p>$\mathrm{P}(x) = \mathrm{P}(W<em>1, …, W_k) = \mathrm{P}(W_1)\mathrm{P}(W_2|W_1)…\mathrm{P}(W_k|W_1,…,W</em>{k-1})$</p><p>也就是说在给定一句话的前k个词，我们希望<strong>语言模型</strong>可以预测第k+1个词是什么，即给出一个第k+1个词可能出现的概率的分布。</p><p>那么如何学习到一个语言模型呢，这里不详细叙述。</p><h2 id="二、如何评价一个语言模型好坏"><a href="#二、如何评价一个语言模型好坏" class="headerlink" title="二、如何评价一个语言模型好坏"></a><strong>二、如何评价一个语言模型好坏</strong></h2><p>在得到不同的语言模型（一元语言模型、二元语言模型….）的时候，我们如何判断一个语言模型是否好还是坏，一般有两种方法：</p><p>1、一种方法将其应用到具体的问题当中，比如机器翻译、speech recognition、spelling corrector等。然后看这个语言模型在这些任务中的表现（extrinsic evaluation，or in-vivo evaluation）。但是，这种方法一方面难以操作，另一方面可能非常耗时，可能跑一个evaluation需要大量时间，费时难操作。</p><p>2、针对第一种方法的缺点，大家想是否可以根据与语言模型自身的一些特性，来设计一种简单易行，而又行之有效的评测指标。于是，人们就发明了perplexity这个指标。</p><p>困惑度（perplexity）的基本思想是：<strong>给测试集的句子赋予较高概率值的语言模型较好,当语言模型训练完之后，测试集中的句子都是正常的句子，那么训练好的模型就是在测试集上的概率越高越好，</strong>公式如下：</p><p>$\mathrm{PP}(W) = \mathrm{P}(w_1, …,w_N) ^ {-\frac{1}{N}} = \sqrt[N]{\frac{1}{\mathrm{P}(w_1,…,w_N)}} $</p><p>由公式可知，<strong>句子概率越大，语言模型越好，迷惑度越小。</strong></p><a id="more"></a><p>下面是一些 ngra­m 模型经 训练文本后在测试集上的困惑度值：</p><p><img src="https://pic1.zhimg.com/80/v2-da6384d62d15cd61e36d5749ff127670_720w.jpg" alt></p><p>可以看到， trigram 模型经训练后，相比于 unigram 模型，困惑度由955跌减至74，这是十分可观的结果。</p><p>这节的核心就是<strong>句子概率越大，语言模型越好，迷惑度越小。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、语言模型&quot;&gt;&lt;a href=&quot;#一、语言模型&quot; class=&quot;headerlink&quot; title=&quot;一、语言模型&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、语言模型&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本文尽量通俗解释一下困惑度的概念。既然题目中写了是用来评价语言模型的好坏，那么首先来看一下语言模型：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单地说，语言模型就是用来计算一个句子的概率的模型，也就是判断一句话是否是人话的概率？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如何计算一个句子的概率呢？给定句子（词语序列）&lt;/p&gt;
&lt;p&gt;$S= W_1, …, W_k$&lt;/p&gt;
&lt;p&gt;它的概率可以表示为：&lt;/p&gt;
&lt;p&gt;$\mathrm{P}(x) = \mathrm{P}(W&lt;em&gt;1, …, W_k) = \mathrm{P}(W_1)\mathrm{P}(W_2|W_1)…\mathrm{P}(W_k|W_1,…,W&lt;/em&gt;{k-1})$&lt;/p&gt;
&lt;p&gt;也就是说在给定一句话的前k个词，我们希望&lt;strong&gt;语言模型&lt;/strong&gt;可以预测第k+1个词是什么，即给出一个第k+1个词可能出现的概率的分布。&lt;/p&gt;
&lt;p&gt;那么如何学习到一个语言模型呢，这里不详细叙述。&lt;/p&gt;
&lt;h2 id=&quot;二、如何评价一个语言模型好坏&quot;&gt;&lt;a href=&quot;#二、如何评价一个语言模型好坏&quot; class=&quot;headerlink&quot; title=&quot;二、如何评价一个语言模型好坏&quot;&gt;&lt;/a&gt;&lt;strong&gt;二、如何评价一个语言模型好坏&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在得到不同的语言模型（一元语言模型、二元语言模型….）的时候，我们如何判断一个语言模型是否好还是坏，一般有两种方法：&lt;/p&gt;
&lt;p&gt;1、一种方法将其应用到具体的问题当中，比如机器翻译、speech recognition、spelling corrector等。然后看这个语言模型在这些任务中的表现（extrinsic evaluation，or in-vivo evaluation）。但是，这种方法一方面难以操作，另一方面可能非常耗时，可能跑一个evaluation需要大量时间，费时难操作。&lt;/p&gt;
&lt;p&gt;2、针对第一种方法的缺点，大家想是否可以根据与语言模型自身的一些特性，来设计一种简单易行，而又行之有效的评测指标。于是，人们就发明了perplexity这个指标。&lt;/p&gt;
&lt;p&gt;困惑度（perplexity）的基本思想是：&lt;strong&gt;给测试集的句子赋予较高概率值的语言模型较好,当语言模型训练完之后，测试集中的句子都是正常的句子，那么训练好的模型就是在测试集上的概率越高越好，&lt;/strong&gt;公式如下：&lt;/p&gt;
&lt;p&gt;$\mathrm{PP}(W) = \mathrm{P}(w_1, …,w_N) ^ {-\frac{1}{N}} = \sqrt[N]{\frac{1}{\mathrm{P}(w_1,…,w_N)}} $&lt;/p&gt;
&lt;p&gt;由公式可知，&lt;strong&gt;句子概率越大，语言模型越好，迷惑度越小。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Pretrained Language Model" scheme="http://haokailong.top/categories/Pretrained-Language-Model/"/>
    
    
      <category term="PLM" scheme="http://haokailong.top/tags/PLM/"/>
    
      <category term="Perplexity" scheme="http://haokailong.top/tags/Perplexity/"/>
    
      <category term="困惑度" scheme="http://haokailong.top/tags/%E5%9B%B0%E6%83%91%E5%BA%A6/"/>
    
      <category term="Pretrained Language Model" scheme="http://haokailong.top/tags/Pretrained-Language-Model/"/>
    
  </entry>
  
  <entry>
    <title>点互信息</title>
    <link href="http://haokailong.top/2021/03/29/%E7%82%B9%E4%BA%92%E4%BF%A1%E6%81%AF/"/>
    <id>http://haokailong.top/2021/03/29/点互信息/</id>
    <published>2021-03-29T05:41:52.000Z</published>
    <updated>2021-03-29T06:04:09.884Z</updated>
    
    <content type="html"><![CDATA[<p>在数据挖掘或者信息检索的相关资料里，经常会用到PMI（Pointwise Mutual Information）这个指标来衡量两个事物之间的相关性。PMI的定义如下：</p><script type="math/tex; mode=display">\mathrm{PMI}(x, y) = \log \frac{\mathrm{p}(x,y)}{\mathrm{p}(x)\mathrm{p}(y)}</script><p>这个定义所体现的原理其实是相当直白的。<strong>在概率论中，我们知道，如果x跟y不相关，则 P(x,y) = P(x)P(y)。二者相关性越大，则 P(x,y) 就相比于 P(x)P(y) 越大。</strong>根据条件概率公式，你还可以写成</p><script type="math/tex; mode=display">\mathrm{PMI}(x,y) \equiv \log \frac{\mathrm{p}(x,y)}{\mathrm{p}(x)\mathrm{p}(y)} \equiv \log \frac{\mathrm{p}(x|y)}{\mathrm{p}(x)} \equiv \log \frac{\mathrm{p}(y|x)}{\mathrm{p}(y)}</script><p>这里的log来自于信息论的理论，而且 log 1 = 0 ，也恰恰表明P(x,y) = P(x)P(y)，相关性为0，而且log是单调递增函数，所以 “P(x,y) 就相比于 P(x)P(y) 越大，x 和 y 相关性越大” 这一性质也得到保留。</p><p>但是若$\mathrm{p}(x,y) = 0$，那就是你有可能会去计算 log 0 = -inf，即得到一个负无穷。为此人们通常会计算一个PPMI（Positive PMI）来避免出现 -inf，即</p><script type="math/tex; mode=display">\mathrm{PPMI}(x, y) =\max( \log \frac{\mathrm{p}(x,y)}{\mathrm{p}(x)\mathrm{p}(y)}, 0)</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在数据挖掘或者信息检索的相关资料里，经常会用到PMI（Pointwise Mutual Information）这个指标来衡量两个事物之间的相关性。PMI的定义如下：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\mathrm{PM
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://haokailong.top/categories/Machine-Learning/"/>
    
    
      <category term="点互信息" scheme="http://haokailong.top/tags/%E7%82%B9%E4%BA%92%E4%BF%A1%E6%81%AF/"/>
    
      <category term="Pointwise Mutual Information" scheme="http://haokailong.top/tags/Pointwise-Mutual-Information/"/>
    
  </entry>
  
  <entry>
    <title>生成模型vs判别模型</title>
    <link href="http://haokailong.top/2021/03/29/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8Bvs%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://haokailong.top/2021/03/29/生成模型vs判别模型/</id>
    <published>2021-03-29T02:19:15.000Z</published>
    <updated>2021-03-29T04:27:25.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版权声明：本文为CSDN博主「CAM-TAY」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u010358304/article/details/79748153" target="_blank" rel="noopener">https://blog.csdn.net/u010358304/article/details/79748153</a></p></blockquote><p>从概率分布的角度考虑，对于一堆样本数据，每个均有特征Xi对应分类标记yi。</p><p>生成模型：学习得到联合概率分布P(x,y)，即特征x和标记y共同出现的概率，然后求条件概率分布。能够学习到数据生成的机制。</p><p>判别模型：学习得到条件概率分布P(y|x)，即在特征x出现的情况下标记y出现的概率。</p><p>数据要求：生成模型需要的数据量比较大，能够较好地估计概率密度；而判别模型对数据样本量的要求没有那么多。</p><p><img src="https://img-blog.csdn.net/20180329224547767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzNTgzMDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;版权声明：本文为CSDN博主「CAM-TAY」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/u010358304/article/d
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://haokailong.top/categories/Machine-Learning/"/>
    
    
      <category term="生成模型" scheme="http://haokailong.top/tags/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="判别模型" scheme="http://haokailong.top/tags/%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="generative" scheme="http://haokailong.top/tags/generative/"/>
    
      <category term="discriminative" scheme="http://haokailong.top/tags/discriminative/"/>
    
  </entry>
  
  <entry>
    <title>nvidia-smi报错NVIDIA-SMI has failed because it couldn&#39;t...</title>
    <link href="http://haokailong.top/2021/03/29/nvidia-smi%E6%8A%A5%E9%94%99NVIDIA-SMI-has-failed-because-it-couldn-t/"/>
    <id>http://haokailong.top/2021/03/29/nvidia-smi报错NVIDIA-SMI-has-failed-because-it-couldn-t/</id>
    <published>2021-03-29T02:04:34.000Z</published>
    <updated>2021-03-29T02:17:58.318Z</updated>
    
    <content type="html"><![CDATA[<font color="red">NVIDIA-SMI has failed because it couldn't communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.</font><p>原因是版本不匹配导致的检测显卡驱动程序异常。</p><h1 id="1-检测版本"><a href="#1-检测版本" class="headerlink" title="1. 检测版本"></a>1. 检测版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dkms</span><br></pre></td></tr></table></figure><p>然后查看对应的驱动版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/src</span><br></pre></td></tr></table></figure><p>对应结果为目录：<code>nvidia-418.87.01</code></p><h1 id="2-重新生成对应的驱动模块"><a href="#2-重新生成对应的驱动模块" class="headerlink" title="2. 重新生成对应的驱动模块"></a>2. 重新生成对应的驱动模块</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dkms install -m nvidia -v 418.87.01</span><br></pre></td></tr></table></figure><p>祝大家科研顺利🤭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;red&quot;&gt;NVIDIA-SMI has failed because it couldn&#39;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is i
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
    
      <category term="nvidia" scheme="http://haokailong.top/tags/nvidia/"/>
    
      <category term="NVIDIA-SMI" scheme="http://haokailong.top/tags/NVIDIA-SMI/"/>
    
  </entry>
  
  <entry>
    <title>unordered_map使用方法</title>
    <link href="http://haokailong.top/2021/03/28/unordered-map%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://haokailong.top/2021/03/28/unordered-map使用方法/</id>
    <published>2021-03-28T15:34:33.000Z</published>
    <updated>2021-03-28T16:08:16.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版权声明：本文为CSDN博主「Cypress1010」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Cypress1010/article/details/53669409" target="_blank" rel="noopener">https://blog.csdn.net/Cypress1010/article/details/53669409</a></p></blockquote><h2 id="unordered-map-无序映射"><a href="#unordered-map-无序映射" class="headerlink" title="unordered_map(无序映射)"></a>unordered_map(无序映射)</h2><p>对于map，前面已经提到过，其内部数据结构为红黑树，因此所有元素插入到map里面都会排好序，而且搜索过程为平衡二叉树搜索，因此时间复杂度为O(logN)。我们知道还有一种快速的搜索方法，那边是哈希(又名散列)，利用哈希函数，通过哈希值能快速的查找到所需元素。unordered_map便是采用这种数据结构实现，unordered _map与map的使用基本一样，都是key/value之间的映射，只是他们内部采用的数据结构不一样。</p><blockquote><p>由于unordered_map内部是用散列表来实现快速查找，因此其内部元素完全是一种无序状态。哈希表利用哈希函数，将关键字的哈希值放都一个桶(bucket)里面，具有相同哈希值的放入到同一个桶。</p></blockquote><h2 id="头文件：-include"><a href="#头文件：-include" class="headerlink" title="头文件：#include "></a>头文件：#include <unordered_map></unordered_map></h2><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; stringmap;</span><br><span class="line"></span><br><span class="line">stringmap first;  <span class="comment">// empty</span></span><br><span class="line"><span class="function">stringmap <span class="title">second</span><span class="params">(&#123;&#123;<span class="string">"apple"</span>, <span class="string">"red"</span>&#125;,&#123;<span class="string">"lemon"</span>, <span class="string">"yellow"</span>&#125;&#125;)</span></span>;  <span class="comment">// init list</span></span><br><span class="line"><span class="function">stringmap <span class="title">third</span><span class="params">(&#123;&#123;<span class="string">"orange"</span>, <span class="string">"orange"</span>&#125;,&#123;<span class="string">"strawberry"</span>, <span class="string">"red"</span>&#125;&#125;)</span></span>;</span><br><span class="line"><span class="function">stringmap <span class="title">fourth</span><span class="params">(third)</span></span>;  <span class="comment">// copy</span></span><br><span class="line"><span class="function">stringmap <span class="title">fifth</span><span class="params">(fourth.begin(), fourth.end())</span></span>;  <span class="comment">// range</span></span><br></pre></td></tr></table></figure><p>容器大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; second.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>获取元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; second[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>元素查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it = second.find(<span class="string">"banana"</span>);  <span class="comment">//返回查找到元素的iterator，如未查找到，返回end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != second.end())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">" "</span> &lt;&lt; (*it).second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>元素修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; second;</span><br><span class="line">second[<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">second[<span class="string">'b'</span>] = <span class="number">2</span>;</span><br><span class="line">second[<span class="string">'c'</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">second.erase ( second.begin() );      <span class="comment">// erasing by iterator</span></span><br><span class="line">second.erase (<span class="string">'a'</span>);             <span class="comment">// erasing by key</span></span><br><span class="line">second.erase ( second.find(<span class="string">'c'</span>), second.end() ); <span class="comment">// erasing by range</span></span><br><span class="line"></span><br><span class="line">second.clear();  <span class="comment">//清空</span></span><br><span class="line">second.swap(first);   <span class="comment">//互换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.bucket_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//返回桶的数量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.bucket_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//返回每个桶的大小</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.bucket(<span class="string">'a'</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//返回当前元素在哪个桶</span></span><br><span class="line">second.rehash(<span class="number">10</span>);   <span class="comment">//设置桶的数量</span></span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>unordered_map内部使用哈希表进行存储与搜索。由于需要使用hash来进行映射，因此需要判断两个关键字是否相等，对于内部类型，可以直接进行判断，如果是用户自定义类型，则需要重载”==”运算符，指定如何判断两个关键字是否相等。以下是在网上摘录的一段代码，个人觉得比较详细的unordered_map的使用方法，这里只是其中一种使用方法：利用函数对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name =  name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the object of hash function */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonHash</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Person&amp; per) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(per.name) ^ hash&lt;<span class="keyword">int</span>&gt;()(per.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the object of compare */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonCmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; personA, <span class="keyword">const</span> Person&amp; personB)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personA.name == personB.name &amp;&amp; personA.age == personB.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* define the unordered_map type */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;Person, <span class="keyword">int</span>, PersonHash, PersonCmp&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">umap m;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom1"</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Tom2"</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"Tom3"</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"Tom4"</span>,<span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"Tom5"</span>,<span class="number">24</span>)</span></span>;</span><br><span class="line">m.insert(umap::value_type(p3, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p4, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p5, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p1, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p2, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里打印出来的顺序于插入顺序并不相同，确切的说是完全无序的 */</span></span><br><span class="line"><span class="keyword">for</span>(umap::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iter-&gt;first.name &lt;&lt; <span class="string">"\t"</span> &lt;&lt; iter-&gt;first.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;版权声明：本文为CSDN博主「Cypress1010」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/Cypress1010/arti
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="STL" scheme="http://haokailong.top/tags/STL/"/>
    
      <category term="unordered_map" scheme="http://haokailong.top/tags/unordered-map/"/>
    
  </entry>
  
  <entry>
    <title>cin, cin.getline(), getline()的用法</title>
    <link href="http://haokailong.top/2021/03/28/cin-cin-getline-getline-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://haokailong.top/2021/03/28/cin-cin-getline-getline-的用法/</id>
    <published>2021-03-28T13:38:20.000Z</published>
    <updated>2021-03-28T13:58:09.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-cin"><a href="#1-cin" class="headerlink" title="1. cin"></a>1. cin</h1><p>用法1：输入一个数字或字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a,b;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法2：接收一个字符串，遇“空格”、“TAB”、“回车”就结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：hello<br>输出：hello</p><p>输入：hello world<br>输出：hello</p></blockquote><h1 id="2-cin-getline"><a href="#2-cin-getline" class="headerlink" title="2. cin.getline()"></a>2. cin.getline()</h1><p>用法:接收一个字符串，可以接收空格并输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> m[<span class="number">20</span>];</span><br><span class="line">     <span class="built_in">cin</span>.getline(m,<span class="number">5</span>);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>输入：hello world<br>输出：hell</p></blockquote><p><strong>接收5个字符到m中，其中最后一个为’\0’，所以只看到4个字符输出；</strong></p><p>如果把5改成20：</p><blockquote><p>输入：hello world<br>输出：hello world</p></blockquote><p>延伸：<br>1、cin.getline()实际上有三个参数，<strong>cin.getline(接收字符串的变量,接收字符个数,结束字符)</strong><br>2、当第三个参数省略时，系统默认为’\0’<br>3、如果将例子中<strong>cin.getline()改为cin.getline(m,5,’a’)</strong>;当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk</p><h1 id="3-getline"><a href="#3-getline" class="headerlink" title="3. getline()"></a>3. getline()</h1><p>用法：接收一个字符串，可以接收空格并输出，需包含<code>#include&lt;string&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：hello world<br>输出：hello world</p></blockquote><h1 id="4-注意的问题"><a href="#4-注意的问题" class="headerlink" title="4. 注意的问题"></a>4. 注意的问题</h1><p>1、<strong>cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数</strong></p><p>2、当同时使用 <strong>cin ,  getline()</strong> 时，需要注意的是，在cin输入流完成之后，getline()之前，需要通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"\n"</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br></pre></td></tr></table></figure><p>的方式将<strong>回车符</strong>作为输入流cin以清除缓存，如果不这样做的话，在控制台上就不会出现getline()的输入提示，而直接跳过，因为程序默认地将之前的变量作为输入流。</p><p>看下面一段程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//standard input(cin)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter an integer value as your age: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;age;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Your ager is: "</span>&lt;&lt;age&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line">    <span class="comment">//cin and string</span></span><br><span class="line">    <span class="built_in">string</span> mystr;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"What's your name? "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    mystr=<span class="string">"\n"</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    </span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello,"</span>&lt;&lt;mystr&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter a F or M as your sex: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;sex;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Your sex is: "</span>&lt;&lt;sex&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"What's your favorite team? "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    mystr=<span class="string">"\n"</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    </span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I like "</span>&lt;&lt;mystr&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>Please enter an integer value as your age: 17<br>Your ager is: 17.<br>What’s your name?<br>Kevin<br>Hello,Kevin.<br>Please enter a F or M as your sex: M<br>Your sex is: M<br>What’s your favorite team? Rocket<br>I like Rocket.<br>请按任意键继续. . .</p></blockquote><p>如果不添加<code>///////////////////////////</code>之间的代码，运行结果为：</p><blockquote><p>Please enter an integer value as your age: 17<br>Your ager is: 17.<br>What’s your name?<br>Hello,.<br>Please enter a F or M as your sex: M<br>Your sex is: M<br>What’s your favorite team? I like .<br>请按任意键继续. . .</p></blockquote><p>其实<code>mystr = &#39;\n&#39;</code>可以去掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-cin&quot;&gt;&lt;a href=&quot;#1-cin&quot; class=&quot;headerlink&quot; title=&quot;1. cin&quot;&gt;&lt;/a&gt;1. cin&lt;/h1&gt;&lt;p&gt;用法1：输入一个数字或字符&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a,b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;a+b&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用法2：接收一个字符串，遇“空格”、“TAB”、“回车”就结束&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：hello&lt;br&gt;输出：hello&lt;/p&gt;
&lt;p&gt;输入：hello world&lt;br&gt;输出：hello&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;2-cin-getline&quot;&gt;&lt;a href=&quot;#2-cin-getline&quot; class=&quot;headerlink&quot; title=&quot;2. cin.getline()&quot;&gt;&lt;/a&gt;2. cin.getline()&lt;/h1&gt;&lt;p&gt;用法:接收一个字符串，可以接收空格并输出&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; m[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;.getline(m,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="ACM" scheme="http://haokailong.top/tags/ACM/"/>
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="OJ" scheme="http://haokailong.top/tags/OJ/"/>
    
      <category term="cin" scheme="http://haokailong.top/tags/cin/"/>
    
      <category term="getline" scheme="http://haokailong.top/tags/getline/"/>
    
      <category term="C" scheme="http://haokailong.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>scanf输入字符型BUG</title>
    <link href="http://haokailong.top/2021/03/28/scanf%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E5%9E%8BBUG/"/>
    <id>http://haokailong.top/2021/03/28/scanf输入字符型BUG/</id>
    <published>2021-03-28T11:30:23.000Z</published>
    <updated>2021-03-28T11:44:21.032Z</updated>
    
    <content type="html"><![CDATA[<p>问题原因是：<strong>键盘缓冲区残余信息</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a); </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a=%d     c=%c/n"</span>,a,c); </span><br><span class="line">    &#125;<span class="keyword">while</span>(c!=<span class="string">'N'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scanf(&quot;%c&quot;, &amp;c);</code>这句不能正常接收字符,什么原因呢？</p><p>我们用<code>printf(&quot;c=%d\n&quot;,c);</code>将c用int表示出来，看看scanf()函数赋给C到底是什么，结果是 c=10, ASCII值为10</p><p>是什么？换行即<code>\n</code>.</p><p>对了，我们每击打一下”Enter”键，向键盘缓冲区发去一个“回车”(\r),一个“换行”(\n),在这里\r被scanf()函数处理掉了（姑且这么认为吧^_^），而\n被scanf()函数“错误”地赋给了c.</p><p>解决办法：</p><ul><li>可以在两个scanf()函数之后加个fflush(stdin);</li><li>还有加getch(); </li><li>getchar();也可以</li></ul><p>但是要视具体scanf()语句加那个，这里就不分析了。但是加fflush(stdin);不管什么情况都可行。</p><h4 id="scanf-quot-c-quot-是会读入空格以及换行的，所以使用时一定要慎重。"><a href="#scanf-quot-c-quot-是会读入空格以及换行的，所以使用时一定要慎重。" class="headerlink" title="scanf(&quot;%c&quot;)是会读入空格以及换行的，所以使用时一定要慎重。"></a><code>scanf(&quot;%c&quot;)</code>是会读入空格以及换行的，所以使用时一定要慎重。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题原因是：&lt;strong&gt;键盘缓冲区残余信息&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="C" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="scanf" scheme="http://haokailong.top/tags/scanf/"/>
    
      <category term="getchar" scheme="http://haokailong.top/tags/getchar/"/>
    
  </entry>
  
  <entry>
    <title>ACM输入输出</title>
    <link href="http://haokailong.top/2021/03/28/ACM%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://haokailong.top/2021/03/28/ACM输入输出/</id>
    <published>2021-03-28T09:18:22.000Z</published>
    <updated>2021-03-28T15:30:19.180Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的笔试中，由于不熟悉ACM模式的输入输出，吃了大亏！所以在此总结和学习，吃一堑长一智。</p><blockquote><p>版权声明：本文为CSDN博主「yang1young」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qiao1245/article/details/53020326" target="_blank" rel="noopener">https://blog.csdn.net/qiao1245/article/details/53020326</a></p></blockquote><h1 id="1-C-输入"><a href="#1-C-输入" class="headerlink" title="1. C++输入"></a>1. C++输入</h1><h2 id="1-1-只有一组测试数据"><a href="#1-1-只有一组测试数据" class="headerlink" title="1.1. 只有一组测试数据"></a>1.1. 只有一组测试数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; iostream &gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a,b; </span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-有多组测试数据，直到读至输入文件结尾为止"><a href="#1-2-有多组测试数据，直到读至输入文件结尾为止" class="headerlink" title="1.2. 有多组测试数据，直到读至输入文件结尾为止"></a>1.2. 有多组测试数据，直到读至输入文件结尾为止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; iostream &gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a,b;</span><br><span class="line">       <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-在开始的时候输入一个N，接下来是N组数据"><a href="#1-3-在开始的时候输入一个N，接下来是N组数据" class="headerlink" title="1.3. 在开始的时候输入一个N，接下来是N组数据"></a>1.3. 在开始的时候输入一个N，接下来是N组数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志"><a href="#1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志" class="headerlink" title="1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志"></a>1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志</h2><p>例如A+B，题目中说明以<code>0, 0</code>结束输入，可以按照以下写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &amp;&amp; (a || b)) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-重定向输入，保存历史"><a href="#1-5-重定向输入，保存历史" class="headerlink" title="1.5. 重定向输入，保存历史"></a>1.5. 重定向输入，保存历史</h2><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"input.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);  <span class="comment">// 输入将被重定向到文件</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码从文件<font color="orange">“input.txt”</font>中读取输入，然后计算后输入到标准输出。</p><p>也可以用<code>freopen</code>函数将标准输出重定向到文件，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  freopen (<span class="string">"output.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"This sentence is redirected to a file.\n"</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello freopen function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fclose (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文件<font color="orange">“output.txt”</font>中显示为：</p><blockquote><p>This sentence is redirected to a file.</p><p>hello freopen function</p></blockquote><h2 id="1-6-输入字符串"><a href="#1-6-输入字符串" class="headerlink" title="1.6. 输入字符串"></a>1.6. 输入字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.getline(buf, <span class="number">255</span>)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中读入字符串通常使用cin.getline函数，可以接受用户的输入的字符，直到已达指定个数，或者用户输入了特定的字符。它的函数声明形式（函数原型）如下：</p><blockquote><p>istream&amp; getline(char line[], int size, char endchar= ‘\n’);<br>char line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。<br>int size : 最多接受几个字符，用户超过size的输入都将不被接受。<br>char endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。</p></blockquote><p><strong>使用<code>getline()</code>函数读取字符串，字符串中可以包含空格</strong></p><p>另一种读取字符串的方式是使用string，但是这种方式是无法读入空格的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; buf) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><blockquote><p>hello world</p></blockquote><p>输出：</p><blockquote><p>hello</p><p>world</p></blockquote><p>默认按照空格进行了切分，读入了两个字符串。</p><h1 id="2-C-输出"><a href="#2-C-输出" class="headerlink" title="2. C++输出"></a>2. C++输出</h1><p>输出有不同的格式要求，不注意的话经常会出现 <code>Presentation Error</code>，而且 PC2 很多时候还判断不出来输出格式错误，就简单的判为 <code>Wrong Answer</code>，所以输出格式一定要注意。</p><h3 id="1、一组输出接着一组输出，中间没有空行"><a href="#1、一组输出接着一组输出，中间没有空行" class="headerlink" title="1、一组输出接着一组输出，中间没有空行"></a>1、一组输出接着一组输出，中间没有空行</h3><p>这也是最简单的，请看题目 <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1010" target="_blank" rel="noopener">SDUT 1010</a>。</p><p>C 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每输出一组结果换行就可以了。</p><h3 id="2、一组接着一组，每一组后面有一空行"><a href="#2、一组接着一组，每一组后面有一空行" class="headerlink" title="2、一组接着一组，每一组后面有一空行"></a>2、一组接着一组，每一组后面有一空行</h3><p>请看题目 <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1016" target="_blank" rel="noopener">SDUT 1016</a>。</p><p>C 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n\n"</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每输出一组结果后输出两个换行就可以了。</p><h3 id="3、一组接着一组，每两组之间有一个空行"><a href="#3、一组接着一组，每两组之间有一个空行" class="headerlink" title="3、一组接着一组，每两组之间有一个空行"></a>3、一组接着一组，每两组之间有一个空行</h3><p>注意与前一种区分开，请看题目 <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1017" target="_blank" rel="noopener">SDUT 1017</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, sum, a;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">        <span class="keyword">if</span> (i != n - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否到达最后一组测试数据了，如果不是最后一组测试数据就多输出一个换行。</p><p><strong><em>很多题目都要求在输出数据的恰当位置加空行。一个空行就是一个单独的”\n”。这里，有的题目说：“After each test case, you should output one blank line”，而有的题目说：“Between each test case, you should ouput one blank line”。要注意After和Between的区别，因为如果多了一或少了空行，将导致Presentation Error甚至Wrong Answer。</em></strong></p><h1 id="3-C语言输入输出"><a href="#3-C语言输入输出" class="headerlink" title="3. C语言输入输出"></a>3. C语言输入输出</h1><p>有时候C++的输入输出可能太慢，不妨使用C语言的输入输出</p><p>主要方法有：</p><blockquote><p>printf ();//把键盘中的各类数据,加以格式控制输出到显示器屏幕上;<br>scanf ();//从键盘上输入各类数据,并存放到程序变量中;<br>puts ()://把数组变量中的一个字符串常量输出到显示器屏幕上;<br>gets ()://从键盘上输入一个字符串常量并放到程序的数组中;<br>putchar ()://把变量中的一个字符常量输出到显示器屏幕上;<br>getchar ()://从键盘上输入一个字符常量,此常量就是该函数的值;<br>sscanf()://从一个字符串中提取各类数据。</p></blockquote><h2 id="3-1-printf"><a href="#3-1-printf" class="headerlink" title="3.1. printf"></a>3.1. printf</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C Programming\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Number = %d\n"</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number1 = %f\n"</span>, <span class="number">13.5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number2 = %f\n"</span>, <span class="number">12.4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"character = %c\n"</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>C Programming<br>Number = 5<br>number1 = 13.500000<br>number2 = 12.400000<br>character = c</p></blockquote><h2 id="3-2-scanf"><a href="#3-2-scanf" class="headerlink" title="3.2. scanf"></a>3.2. scanf</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> num1;</span><br><span class="line"><span class="keyword">double</span> num2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;num1);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;num2);</span><br><span class="line"></span><br><span class="line">fflush(<span class="built_in">stdin</span>);  <span class="comment">// 清除缓冲区 </span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%f"</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num = %d\n"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num1 = %f\n"</span>, num1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num2 = %lf\n"</span>, num2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"character = %c\n"</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"multiple values = %d, %f"</span>, a, b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>num = 15<br>num1 = 1.200000<br>num2 = 3.560000<br>character = z<br>multiple values = 7, 7.770000</p></blockquote><h2 id="3-3-puts-gets"><a href="#3-3-puts-gets" class="headerlink" title="3.3. puts, gets"></a>3.3. puts, gets</h2><p><code>gets()</code>与<code>scanf(&quot;%s&quot;)</code>均可用于读取字符串。</p><p>1.不同点：</p><p>scanf不能接受空格、制表符Tab、回车等；</p><p><strong>而gets能够接受空格、制表符Tab和回车等；</strong></p><p>scanf ：当遇到回车，空格和tab键会自动在字符串后面添加’\0’，但是回车，空格和tab键仍会留在输入的缓冲区中。</p><p><strong>gets：可接受回车键之前输入的所有字符，并用’\0’替代 ‘\n’.回车键不会留在输入缓冲区中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入: hello world</p><p>输出: hello</p></blockquote><p>从键盘输入字符串<code>hello world</code>时，遇到空格，scanf()就认为输入结束了，所以buf中存放的字符串是 ‘hello\0’。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a中保存的字符串为：%s\n"</span>,a);</span><br><span class="line">    c=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c中保存的字符为：%c "</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入asdf回车，<strong>因为scanf会将回车保留在缓冲区中，所以回车会紧接着被c取得而不需要再额外输入，所以a中存储的是’asdf\0’，字符c=’\n’</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    gets(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b中保存的字符串为：%s\n"</span>,b);</span><br><span class="line">    d=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d中保存的字符为：%c"</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着输入<code>as df</code>回车，因为gets会将’\n’替换成’\0’，所以b字符串中保留的是<code>’as df\0’</code>，并且还是要继续输入d的值。</p><p><strong><code>printf()</code>与<code>puts()</code>不同点：</strong><br>puts（）在输出字符串时会将’\0’自动转换成’\n’进行输出，也就是说，puts方法输出完字符串后会自动换行。</p><h2 id="3-4-putchar-getchar"><a href="#3-4-putchar-getchar" class="headerlink" title="3.4. putchar, getchar"></a>3.4. putchar, getchar</h2><p><code>putchar()</code>是put character的缩写。作用是输出<strong>一个</strong>字符的值。</p><p>向计算机输入一个字符可以调用<code>getchar()</code>函数。</p><font color="orange">**强烈建议输入字符时均使用`getchar()`代替`scanf("%c")`，避免出现意想不到的BUG**</font><h2 id="3-5-sscanf"><a href="#3-5-sscanf" class="headerlink" title="3.5. sscanf"></a>3.5. sscanf</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure><p>从字符串读取格式化输入。</p><p>sscanf用法跟scanf差不多，只不过scanf是从标准输入stdin中读入，而sscanf函数是从指定的字符串中读取。相比scanf函数，sscanf函数多了第一个参数，传入一个字符串。</p><p><strong>取指定长度的字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">"123456"</span>,<span class="string">"%3s"</span>,str);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>123</p></blockquote><p><strong>将表示数字的字符串转换成整型变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">"123456"</span>, <span class="string">"%d"</span>, &amp;res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>123456</p></blockquote><p><strong>取需要的字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year,month,day;</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">"2017.12.5"</span>,<span class="string">"%d.%d.%d"</span>,&amp;year,&amp;month,&amp;day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"year:%d,month:%d,day:%d\n"</span>,year,month,day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>year:2017,month:12,day:5</p></blockquote><h2 id="3-6-带格式化的字符串输出"><a href="#3-6-带格式化的字符串输出" class="headerlink" title="3.6. 带格式化的字符串输出"></a>3.6. 带格式化的字符串输出</h2><p>有些题目要求输出这样的字符串：<code>abc*****de****f</code>，其中“*”代表空格。<br>要求是这样的：str1在前5个字符中左对齐，str2在第6到第10个字符中右对齐，str3在第11到第15个字符中右对齐。<br>可行的做法是，先初始化一个数组，用’ ‘（空格）填充，再在相应的位置填相应的内容。用程序来表述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>, str2[] = <span class="string">"de"</span>, str3[] = <span class="string">"f"</span>;</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">' '</span>, <span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">// 用空格填充</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%s"</span>, str1);</span><br><span class="line">str[<span class="built_in">strlen</span>(str1)] = <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str + <span class="number">5</span>, <span class="string">"%5s"</span>, str2);</span><br><span class="line">str[<span class="number">10</span>] = <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str + <span class="number">10</span>, <span class="string">"%5s"</span>, str3);</span><br><span class="line">str[<span class="number">15</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><p>关键的部分：<br>（1）在调用sprintf后，要清除不恰当字符串结束符（第5,7行）；<br>（2）在恰当的位置添加字符串结束符（第9行）。</p><h2 id="3-7-二维数组的输出"><a href="#3-7-二维数组的输出" class="headerlink" title="3.7. 二维数组的输出"></a>3.7. 二维数组的输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="blue">**注意每行最后不要多输出1个空格**</font><h1 id="4-格式化"><a href="#4-格式化" class="headerlink" title="4. 格式化"></a>4. 格式化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%d  以十进制形式输出带符号整数(正数不输出符号)   </span><br><span class="line">%o  以八进制形式输出无符号整数(不输出前缀O)   </span><br><span class="line">%x  以十六进制形式输出无符号整数(不输出前缀OX)   </span><br><span class="line">%u  以十进制形式输出无符号整数   </span><br><span class="line">%f  以小数形式输出单精度实数   </span><br><span class="line">%lf 以小数形式输出双精度实数 </span><br><span class="line">%e  以指数形式输出单、双精度实数   </span><br><span class="line">%g  以%f%e中较短的输出宽度输出单、双精度实数   </span><br><span class="line">%c  输出单个字符   </span><br><span class="line">%s  输出字符串</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> a = <span class="number">125.78</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%e\n"</span>, a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>125.779999<br>1.257800e+002</p></blockquote><h2 id="4-1-C语言精度控制"><a href="#4-1-C语言精度控制" class="headerlink" title="4.1. C语言精度控制"></a>4.1. C语言精度控制</h2><p>精度格式符以“.”开头，后跟十进制整数。意义是：如果输出数字，则表示小数的位数；如果输出的是字符， 则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> a = <span class="number">1.1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, a);  <span class="comment">// 保留两位小数，补齐</span></span><br><span class="line"><span class="keyword">double</span> b = <span class="number">123456789.456</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, b);  <span class="comment">// 保留两位小数，截断</span></span><br><span class="line"><span class="keyword">double</span> c=<span class="number">24212345.24232</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%020.4f\n"</span>, c);  <span class="comment">// 保留四位小数，输出占20位，若有空余的位补0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>1.10<br>123456789.46<br>000000024212345.2423</p></blockquote><h2 id="4-2-C-精度控制"><a href="#4-2-C-精度控制" class="headerlink" title="4.2. C++精度控制"></a>4.2. C++精度控制</h2><p>(只作了解，在笔试具体使用时，还是要用<code>printf()</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> num = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><p>1 设置对齐方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>1.25</p></blockquote><p>2 设置输出宽度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>​    1.25</p></blockquote><p>3 将宽度多余的部分用某个字符（如：’0’）填充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>00001.25</p></blockquote><p>4 设置精度：保留**位有效数字，如果小数点最后面有0，则自动去掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>); <span class="comment">//设置输出精度，保留有效数字</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>000001.2</p></blockquote><p>5 保留小数点后**位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span>.flags(ios::fixed);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">4</span>); <span class="comment">//设置输出精度，</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>001.2500</p></blockquote><p>6 保留小数点后有效的位数。如：1.25 保留4位有效数字后的1.250中0的显示，要依靠cout.setf(ios::showpoint)函数（因为保留有效数字的函数不会保留没用的0有效位）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::showpoint); <span class="comment">//将小数精度后面的0显示出来</span></span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">4</span>); <span class="comment">//设置输出精度，保留有效数字</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>0001.250</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的笔试中，由于不熟悉ACM模式的输入输出，吃了大亏！所以在此总结和学习，吃一堑长一智。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为CSDN博主「yang1young」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/qiao1245/article/details/53020326&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qiao1245/article/details/53020326&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-C-输入&quot;&gt;&lt;a href=&quot;#1-C-输入&quot; class=&quot;headerlink&quot; title=&quot;1. C++输入&quot;&gt;&lt;/a&gt;1. C++输入&lt;/h1&gt;&lt;h2 id=&quot;1-1-只有一组测试数据&quot;&gt;&lt;a href=&quot;#1-1-只有一组测试数据&quot; class=&quot;headerlink&quot; title=&quot;1.1. 只有一组测试数据&quot;&gt;&lt;/a&gt;1.1. 只有一组测试数据&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt; iostream &amp;gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a,b; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a+b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-2-有多组测试数据，直到读至输入文件结尾为止&quot;&gt;&lt;a href=&quot;#1-2-有多组测试数据，直到读至输入文件结尾为止&quot; class=&quot;headerlink&quot; title=&quot;1.2. 有多组测试数据，直到读至输入文件结尾为止&quot;&gt;&lt;/a&gt;1.2. 有多组测试数据，直到读至输入文件结尾为止&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt; iostream &amp;gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a,b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a+b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-3-在开始的时候输入一个N，接下来是N组数据&quot;&gt;&lt;a href=&quot;#1-3-在开始的时候输入一个N，接下来是N组数据&quot; class=&quot;headerlink&quot; title=&quot;1.3. 在开始的时候输入一个N，接下来是N组数据&quot;&gt;&lt;/a&gt;1.3. 在开始的时候输入一个N，接下来是N组数据&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, b, n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (n--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志&quot;&gt;&lt;a href=&quot;#1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志&quot; class=&quot;headerlink&quot; title=&quot;1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志&quot;&gt;&lt;/a&gt;1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志&lt;/h2&gt;&lt;p&gt;例如A+B，题目中说明以&lt;code&gt;0, 0&lt;/code&gt;结束输入，可以按照以下写法：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;amp;&amp;amp; (a || b)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-5-重定向输入，保存历史&quot;&gt;&lt;a href=&quot;#1-5-重定向输入，保存历史&quot; class=&quot;headerlink&quot; title=&quot;1.5. 重定向输入，保存历史&quot;&gt;&lt;/a&gt;1.5. 重定向输入，保存历史&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="ACM" scheme="http://haokailong.top/tags/ACM/"/>
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="OJ" scheme="http://haokailong.top/tags/OJ/"/>
    
      <category term="iostream" scheme="http://haokailong.top/tags/iostream/"/>
    
  </entry>
  
  <entry>
    <title>整除3的最大和</title>
    <link href="http://haokailong.top/2021/03/28/%E6%95%B4%E9%99%A43%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://haokailong.top/2021/03/28/整除3的最大和/</id>
    <published>2021-03-28T09:06:14.000Z</published>
    <updated>2021-03-28T09:09:31.110Z</updated>
    
    <content type="html"><![CDATA[<p>对应于LeetCode. 1262. Greatest Sum Divisible by Three.</p><p>关键在于想到<code>模三取余</code>的操作。这道题及其变种是经常遇到的题目。</p><p>解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> **matrix = <span class="keyword">new</span> <span class="keyword">int</span>* [n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)  <span class="comment">// 初始化 </span></span><br><span class="line">   matrix[<span class="number">0</span>][j] = <span class="number">0</span>; </span><br><span class="line">matrix[<span class="number">0</span>][nums[<span class="number">0</span>]%<span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) </span><br><span class="line">        matrix[i][j] = matrix[i<span class="number">-1</span>][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[i] + matrix[i<span class="number">-1</span>][j];</span><br><span class="line">        matrix[i][sum%<span class="number">3</span>] = max(sum, matrix[i][sum%<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> matrix[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对应于LeetCode. 1262. Greatest Sum Divisible by Three.&lt;/p&gt;
&lt;p&gt;关键在于想到&lt;code&gt;模三取余&lt;/code&gt;的操作。这道题及其变种是经常遇到的题目。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="DP" scheme="http://haokailong.top/tags/DP/"/>
    
      <category term="动态规划" scheme="http://haokailong.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Dynamic Programming" scheme="http://haokailong.top/tags/Dynamic-Programming/"/>
    
      <category term="dp" scheme="http://haokailong.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch分布式训练-DistributedDataParallel</title>
    <link href="http://haokailong.top/2021/03/24/Pytorch%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83-DistributedDataParallel/"/>
    <id>http://haokailong.top/2021/03/24/Pytorch分布式训练-DistributedDataParallel/</id>
    <published>2021-03-24T12:51:04.000Z</published>
    <updated>2021-03-24T14:31:56.800Z</updated>
    
    <content type="html"><![CDATA[<p>与 DataParallel 的单进程控制多 GPU 不同，在 distributed 的帮助下，我们只需要编写一份代码，torch 就会自动将其分配给n个进程，分别在n个 GPU 上运行。</p><p>和单进程训练不同的是，多进程训练需要注意以下事项：</p><ul><li>在喂数据的时候，一个batch被分到了好几个进程，每个进程在取数据的时候要确保拿到的是不同的数据（<code>DistributedSampler</code>）；</li><li>要告诉每个进程自己是谁，使用哪块GPU（<code>args.local_rank</code>）；</li><li>在做BatchNormalization的时候要注意同步数据。</li></ul><h2 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1. 使用方式"></a>1. 使用方式</h2><h3 id="1-1-启动方式的改变"><a href="#1-1-启动方式的改变" class="headerlink" title="1.1. 启动方式的改变"></a>1.1. 启动方式的改变</h3><p>在多进程的启动方面，我们不用自己手写 multiprocess 进行一系列复杂的CPU、GPU分配任务，PyTorch为我们提供了一个很方便的启动器 <code>torch.distributed.launch</code> 用于启动文件，所以我们运行训练代码的方式就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=0,1,2,3 python -m torch.distributed.launch --nproc_per_node=4 main.py</span><br></pre></td></tr></table></figure><p>其中的 <code>--nproc_per_node</code> 参数用于指定为当前主机创建的进程数，由于我们是单机多卡，所以这里node数量为1，所以我们这里设置为所使用的GPU数量即可。</p><h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2. 初始化"></a>1.2. 初始化</h3><p>在启动器为我们启动python脚本后，在执行过程中，启动器会将当前进程的（其实就是 GPU的）index 通过参数传递给 python，我们可以这样获得当前进程的 index：即通过参数 <code>local_rank</code> 来告诉我们<strong>当前进程使用的是哪个GPU</strong>，用于我们在每个进程中指定不同的device：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--local_rank'</span>, type=int, default=<span class="number">0</span>，help=<span class="string">'node rank for distributed training'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    args = parse()</span><br><span class="line">    torch.cuda.set_device(args.local_rank)</span><br><span class="line">    torch.distributed.init_process_group(</span><br><span class="line">        <span class="string">'nccl'</span>,</span><br><span class="line">        init_method=<span class="string">'env://'</span></span><br><span class="line">    )</span><br><span class="line">    device = torch.device(<span class="string">f'cuda:<span class="subst">&#123;args.local_rank&#125;</span>'</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中 torch.distributed.<strong>init_process_group</strong> 用于<strong>初始化GPU通信方式（NCCL）和参数的获取方式（env代表通过环境变量）</strong>。使用 init_process_group 设置GPU之间通信使用的后端和端口，通过 NCCL 实现 GPU 通信。</p><h3 id="1-3-DataLoader"><a href="#1-3-DataLoader" class="headerlink" title="1.3. DataLoader"></a>1.3. DataLoader</h3><p>在读取数据的时候，我们要保证一个batch里的数据<strong>被均摊到每个进程上</strong>，每个进程都能获取到不同的数据，但如果我们手动去告诉每个进程拿哪些数据的话太麻烦了，PyTorch也为我们封装好了这一方法。之后，使用 <strong>DistributedSampler 对数据集进行划分</strong>。如此前我们介绍的那样，它能帮助我们将每个 batch 划分成几个 partition，在当前进程中只需要获取和 rank 对应的那个 partition 进行训练。</p><p>所以我们在初始化 <code>data loader</code> 的时候需要使用到 <code>torch.utils.data.distributed.DistributedSampler</code> 这个特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_sampler = torch.utils.data.distributed.DistributedSampler(train_dataset)</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=..., sampler=train_sampler)</span><br></pre></td></tr></table></figure><p>这样就能给<strong>每个进程一个不同的 sampler</strong>，告诉每个<strong>进程自己分别取哪些数据</strong>。</p><h3 id="1-4-模型的初始化"><a href="#1-4-模型的初始化" class="headerlink" title="1.4. 模型的初始化"></a>1.4. 模型的初始化</h3><p>和 <code>nn.DataParallel</code> 的方式一样，我们对于模型的初始化也是简单的一句话就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank])</span><br></pre></td></tr></table></figure><p>使用 DistributedDataParallel 包装模型，它能帮助我们为不同 GPU 上求得的梯度进行 all reduce（即汇总不同 GPU 计算所得的梯度，并同步计算结果）。all reduce 后不同 GPU 中模型的梯度均为 all reduce 之前各 GPU 梯度的均值。</p><h3 id="1-5-同步Batch-Normalization"><a href="#1-5-同步Batch-Normalization" class="headerlink" title="1.5. 同步Batch Normalization"></a>1.5. 同步Batch Normalization</h3><p><a href="https://zhuanlan.zhihu.com/p/40496177" target="_blank" rel="noopener">为什么要同步BN？</a></p><p>现有的标准 Batch Normalization 因为使用数据并行（Data Parallel），是单卡的实现模式，只对单个卡上对样本进行归一化，相当于减小了批量大小（batch-size）（详见BN工作原理部分）。 对于比较消耗显存的训练任务时，往往单卡上的相对批量过小，影响模型的收敛效果。<strong>之前在我们在图像语义分割的实验中，Jerry和我就发现使用大模型的效果反而变差，实际上就是BN在作怪</strong>。 跨卡同步 Batch Normalization 可以使用全局的样本进行归一化，这样相当于‘增大‘了批量大小，这样训练效果不再受到使用 GPU 数量的影响。 最近在图像分割、物体检测的论文中，使用跨卡BN也会显著地提高实验效果，所以跨卡 BN 已然成为竞赛刷分、发论文的必备神器。</p><p><font color="red">可惜 PyTorch 并没有为我们实现这一功能</font>，在接下来的介绍中我们会在 <code>apex</code> 中看到这一功能。</p><h2 id="2-汇总"><a href="#2-汇总" class="headerlink" title="2. 汇总"></a>2. 汇总</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> DataParallel</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> distributed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(<span class="number">30000</span>, <span class="number">50</span>, padding_idx=<span class="number">0</span>)</span><br><span class="line">        self.linear = nn.Linear(<span class="number">50</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, ids, bag_labels, E1s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param ids: (sents, seq_len) &lt;- (8, 120)</span></span><br><span class="line"><span class="string">        :param bag_labels: (bags, class_num) &lt;- (3, 2)</span></span><br><span class="line"><span class="string">        :param E1s: (bags, variable) &lt;- (3, variable)</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">'ids '</span>, ids.shape)</span><br><span class="line">        print(<span class="string">'bag_labels '</span>, bag_labels.shape)</span><br><span class="line">        print(<span class="string">'E1s '</span>, E1s)</span><br><span class="line">        print(<span class="string">'============================='</span>)</span><br><span class="line">        x = self.embedding(ids)</span><br><span class="line">        x = x.mean(dim=<span class="number">1</span>)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Data, self).__init__()</span><br><span class="line">        self.x = torch.randint(<span class="number">0</span>, <span class="number">9999</span>, size=(<span class="number">1000</span>, <span class="number">120</span>))  <span class="comment"># 1000 samples</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_batch</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        ids = torch.stack(data, dim=<span class="number">0</span>)</span><br><span class="line">        bag_labels = torch.randint(<span class="number">0</span>, <span class="number">2</span>, size=(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">        E1s = [[<span class="number">15</span>, <span class="number">39</span>], [<span class="number">9537</span>], [<span class="number">1</span>, <span class="number">70</span>, <span class="number">5132</span>]]</span><br><span class="line">        <span class="keyword">return</span> ids, bag_labels, E1s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--local_rank'</span>, default=<span class="number">-1</span>, type=int,  <span class="comment"># 用于启动器告知当前进程GPU号</span></span><br><span class="line">                        help=<span class="string">'node rank for distributed training'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    distributed.init_process_group(<span class="string">"nccl"</span>)</span><br><span class="line">    torch.cuda.set_device(args.local_rank)</span><br><span class="line"></span><br><span class="line">    train_set = Data()</span><br><span class="line">    train_sampler = torch.utils.data.distributed.DistributedSampler(train_set)</span><br><span class="line">    train_loader = DataLoader(train_set, batch_size=<span class="number">8</span>, sampler=train_sampler, drop_last=<span class="literal">True</span>,</span><br><span class="line">                              collate_fn=train_set.generate_batch)</span><br><span class="line"></span><br><span class="line">    device = torch.device(args.local_rank)</span><br><span class="line">    model = Model().to(device)</span><br><span class="line">    model = DistributedDataParallel(model, device_ids=[args.local_rank])</span><br><span class="line"></span><br><span class="line">    optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line">    loss_func = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">"epoch &#123;&#125;"</span>.format(epoch))</span><br><span class="line">        <span class="keyword">for</span> step, data <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">            ids = data[<span class="number">0</span>].to(device)</span><br><span class="line">            bag_labels = data[<span class="number">1</span>].to(device)</span><br><span class="line">            E1s = data[<span class="number">2</span>]</span><br><span class="line">            logits = model(ids, bag_labels, E1s)</span><br><span class="line">            labels = torch.randint(<span class="number">0</span>, <span class="number">2</span>, size=(<span class="number">8</span>, )).cuda()</span><br><span class="line">            loss = loss_func(logits, labels)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br></pre></td></tr></table></figure><p>在使用时，调用 torch.distributed.launch 启动器启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1,2 python -m torch.distributed.launch --nproc_per_node=2 run.py</span><br></pre></td></tr></table></figure><h3 id="2-1-数据切分"><a href="#2-1-数据切分" class="headerlink" title="2.1. 数据切分"></a>2.1. 数据切分</h3><p>在实验时发现，使用<code>DistributedDataParallel</code>不会对数据进行切分，应该是与使用了多个进程有关。因此可以用于对数据要求比较苛刻的实验环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与 DataParallel 的单进程控制多 GPU 不同，在 distributed 的帮助下，我们只需要编写一份代码，torch 就会自动将其分配给n个进程，分别在n个 GPU 上运行。&lt;/p&gt;
&lt;p&gt;和单进程训练不同的是，多进程训练需要注意以下事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在喂数据的时候，一个batch被分到了好几个进程，每个进程在取数据的时候要确保拿到的是不同的数据（&lt;code&gt;DistributedSampler&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;要告诉每个进程自己是谁，使用哪块GPU（&lt;code&gt;args.local_rank&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;在做BatchNormalization的时候要注意同步数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-使用方式&quot;&gt;&lt;a href=&quot;#1-使用方式&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方式&quot;&gt;&lt;/a&gt;1. 使用方式&lt;/h2&gt;&lt;h3 id=&quot;1-1-启动方式的改变&quot;&gt;&lt;a href=&quot;#1-1-启动方式的改变&quot; class=&quot;headerlink&quot; title=&quot;1.1. 启动方式的改变&quot;&gt;&lt;/a&gt;1.1. 启动方式的改变&lt;/h3&gt;&lt;p&gt;在多进程的启动方面，我们不用自己手写 multiprocess 进行一系列复杂的CPU、GPU分配任务，PyTorch为我们提供了一个很方便的启动器 &lt;code&gt;torch.distributed.launch&lt;/code&gt; 用于启动文件，所以我们运行训练代码的方式就变成了这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CUDA_VISIBLE_DEVICES=0,1,2,3 python -m torch.distributed.launch --nproc_per_node=4 main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的 &lt;code&gt;--nproc_per_node&lt;/code&gt; 参数用于指定为当前主机创建的进程数，由于我们是单机多卡，所以这里node数量为1，所以我们这里设置为所使用的GPU数量即可。&lt;/p&gt;
&lt;h3 id=&quot;1-2-初始化&quot;&gt;&lt;a href=&quot;#1-2-初始化&quot; class=&quot;headerlink&quot; title=&quot;1.2. 初始化&quot;&gt;&lt;/a&gt;1.2. 初始化&lt;/h3&gt;&lt;p&gt;在启动器为我们启动python脚本后，在执行过程中，启动器会将当前进程的（其实就是 GPU的）index 通过参数传递给 python，我们可以这样获得当前进程的 index：即通过参数 &lt;code&gt;local_rank&lt;/code&gt; 来告诉我们&lt;strong&gt;当前进程使用的是哪个GPU&lt;/strong&gt;，用于我们在每个进程中指定不同的device：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="Pytorch" scheme="http://haokailong.top/tags/Pytorch/"/>
    
      <category term="DistributedDataParallel" scheme="http://haokailong.top/tags/DistributedDataParallel/"/>
    
  </entry>
  
  <entry>
    <title>DataParallel数据切分的方式</title>
    <link href="http://haokailong.top/2021/03/24/DataParallel%E6%95%B0%E6%8D%AE%E5%88%87%E5%88%86%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://haokailong.top/2021/03/24/DataParallel数据切分的方式/</id>
    <published>2021-03-24T12:36:55.000Z</published>
    <updated>2021-03-24T12:43:00.925Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用DataParallel时，需要仔细探讨Pytorch默认的数据划分方式，于是做个实验进行尝试。</p><p>先说结论：</p><h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1. 结论"></a>1. 结论</h2><ol><li>对于tensor型数据，平均划分；如果不能整除，从前到后补充</li><li>对于非tensor型数据，复制到每台设备</li></ol><a id="more"></a><h2 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> DataParallel</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(<span class="number">30000</span>, <span class="number">50</span>, padding_idx=<span class="number">0</span>)</span><br><span class="line">        self.linear = nn.Linear(<span class="number">50</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, ids, bag_labels, E1s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param ids: (sents, seq_len) &lt;- (8, 120)</span></span><br><span class="line"><span class="string">        :param bag_labels: (bags, class_num) &lt;- (3, 2)</span></span><br><span class="line"><span class="string">        :param E1s: (bags, variable) &lt;- (3, variable)</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"ids "</span>, ids.shape)</span><br><span class="line">        print(<span class="string">"bag_labels "</span>, bag_labels.shape)</span><br><span class="line">        print(<span class="string">"E1s "</span>, E1s)</span><br><span class="line">        print(<span class="string">'============================='</span>)</span><br><span class="line">        x = self.embedding(ids)</span><br><span class="line">        x = x.mean(dim=<span class="number">1</span>)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Data, self).__init__()</span><br><span class="line">        self.x = torch.randint(<span class="number">0</span>, <span class="number">9999</span>, size=(<span class="number">1000</span>, <span class="number">120</span>))  <span class="comment"># 1000 samples</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 设置可见显卡 (物理层)</span></span><br><span class="line">    os.environ[<span class="string">"CUDA_DEVICE_ORDER"</span>] = <span class="string">"PCI_BUS_ID"</span></span><br><span class="line">    os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"1, 2"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置并行显卡 (逻辑层)</span></span><br><span class="line">    device = torch.device(<span class="string">"cuda:0"</span>)</span><br><span class="line">    model = Model().to(device)  <span class="comment"># 发送到设备</span></span><br><span class="line">    model = DataParallel(model, device_ids=[<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 多卡训练</span></span><br><span class="line">    loader = DataLoader(Data(), batch_size=<span class="number">8</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">    optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> step, data <span class="keyword">in</span> enumerate(loader):</span><br><span class="line">            data = data.to(device)</span><br><span class="line">            bag_labels = torch.randint(<span class="number">0</span>, <span class="number">2</span>, size=(<span class="number">3</span>, <span class="number">2</span>)).to(device)</span><br><span class="line">            E1s = [[<span class="number">15</span>, <span class="number">39</span>], [<span class="number">9537</span>], [<span class="number">1</span>, <span class="number">70</span>, <span class="number">5132</span>]]</span><br><span class="line">            logits = model(data, bag_labels, E1s)</span><br><span class="line">            print(<span class="string">"step &#123;&#125;"</span>.format(step))</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">step 87</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([2, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([1, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">step 88</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([2, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([1, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在使用DataParallel时，需要仔细探讨Pytorch默认的数据划分方式，于是做个实验进行尝试。&lt;/p&gt;
&lt;p&gt;先说结论：&lt;/p&gt;
&lt;h2 id=&quot;1-结论&quot;&gt;&lt;a href=&quot;#1-结论&quot; class=&quot;headerlink&quot; title=&quot;1. 结论&quot;&gt;&lt;/a&gt;1. 结论&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对于tensor型数据，平均划分；如果不能整除，从前到后补充&lt;/li&gt;
&lt;li&gt;对于非tensor型数据，复制到每台设备&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="Pytorch" scheme="http://haokailong.top/tags/Pytorch/"/>
    
      <category term="DataParallel" scheme="http://haokailong.top/tags/DataParallel/"/>
    
      <category term="tensor" scheme="http://haokailong.top/tags/tensor/"/>
    
  </entry>
  
  <entry>
    <title>CUDA_DEVICE_ORDER</title>
    <link href="http://haokailong.top/2021/03/24/CUDA-DEVICE-ORDER/"/>
    <id>http://haokailong.top/2021/03/24/CUDA-DEVICE-ORDER/</id>
    <published>2021-03-24T08:12:28.000Z</published>
    <updated>2021-03-24T08:46:33.508Z</updated>
    
    <content type="html"><![CDATA[<p>NVML工具nvidia-smi按设备的PCI Bus ID 为设备分配索引序号，由于PCI Bus ID 是硬件相关的，我们把设备的 PCI Bus ID 或者按该ID分配的索引号为物理ID。</p><p>CUDA应用运行时进行设备查询（比如deviceQuery）返回的设备ID可能与物理ID不一致，譬如下面这位网友遇到的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## NVML id 是 物理ID，CUDA index是CUDA应用查询返回的设备ID</span></span><br><span class="line">NVML id 0 maps to Cuda index 4</span><br><span class="line">NVML id 1 maps to Cuda index 5</span><br><span class="line">NVML id 2 maps to Cuda index 6</span><br><span class="line">NVML id 3 maps to Cuda index 7</span><br><span class="line">NVML id 4 maps to Cuda index 0</span><br><span class="line">NVML id 5 maps to Cuda index 1</span><br><span class="line">NVML id 6 maps to Cuda index 2</span><br><span class="line">NVML id 7 maps to Cuda index 3</span><br><span class="line">NVML id 8 maps to Cuda index 8</span><br><span class="line">NVML id 9 maps to Cuda index 9</span><br><span class="line">NVML id 10 maps to Cuda index 10</span><br><span class="line">NVML id 11 maps to Cuda index 11</span><br><span class="line">NVML id 12 maps to Cuda index 12</span><br><span class="line">NVML id 13 maps to Cuda index 13</span><br><span class="line">NVML id 14 maps to Cuda index 14</span><br><span class="line">NVML id 15 maps to Cuda index 15</span><br></pre></td></tr></table></figure><p>我们可以通过设置 CUDA_DEVICE_ORDER = PCI_BUS_ID 来要求运行时设备查询按照 PCI_BUS_ID 的顺序索引，从而使得  设备ID=物理ID  保证CUDA应用按期望使用指定设备。目前最佳的设置方法是同时设置 CUDA_DEVICE_ORDER = PCI_BUS_ID 和 CUDA_VISIBLE_DEVICES 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">"CUDA_DEVICE_ORDER"</span>] = <span class="string">"PCI_BUS_ID"</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"2, 3"</span></span><br></pre></td></tr></table></figure><p>当你添加这两行代码后，那么device_ids[0]默认的就是第2号卡，你的模型也会初始化在第2号卡上了，而不会占用第0号卡了。<strong>这里简单说一下设置上面两行代码后，那么对这个程序而言可见的只有2和3号卡，和其他的卡没有关系，这是物理上的号卡，逻辑上来说其实是对应0和1号卡，即device_ids[0]对应的就是第2号卡，device_ids[1]对应的就是第3号卡</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NVML工具nvidia-smi按设备的PCI Bus ID 为设备分配索引序号，由于PCI Bus ID 是硬件相关的，我们把设备的 PCI Bus ID 或者按该ID分配的索引号为物理ID。&lt;/p&gt;
&lt;p&gt;CUDA应用运行时进行设备查询（比如deviceQuery）返回
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="CUDA" scheme="http://haokailong.top/tags/CUDA/"/>
    
      <category term="CUDA_DEVICE_ORDER" scheme="http://haokailong.top/tags/CUDA-DEVICE-ORDER/"/>
    
      <category term="CUDA_VISIBLE_DEVICES" scheme="http://haokailong.top/tags/CUDA-VISIBLE-DEVICES/"/>
    
  </entry>
  
</feed>
