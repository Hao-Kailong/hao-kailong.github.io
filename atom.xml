<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hold the Torch</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haokailong.top/"/>
  <updated>2021-03-28T16:08:16.181Z</updated>
  <id>http://haokailong.top/</id>
  
  <author>
    <name>dinosaur</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>unordered_map使用方法</title>
    <link href="http://haokailong.top/2021/03/28/unordered-map%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://haokailong.top/2021/03/28/unordered-map使用方法/</id>
    <published>2021-03-28T15:34:33.000Z</published>
    <updated>2021-03-28T16:08:16.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版权声明：本文为CSDN博主「Cypress1010」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Cypress1010/article/details/53669409" target="_blank" rel="noopener">https://blog.csdn.net/Cypress1010/article/details/53669409</a></p></blockquote><h2 id="unordered-map-无序映射"><a href="#unordered-map-无序映射" class="headerlink" title="unordered_map(无序映射)"></a>unordered_map(无序映射)</h2><p>对于map，前面已经提到过，其内部数据结构为红黑树，因此所有元素插入到map里面都会排好序，而且搜索过程为平衡二叉树搜索，因此时间复杂度为O(logN)。我们知道还有一种快速的搜索方法，那边是哈希(又名散列)，利用哈希函数，通过哈希值能快速的查找到所需元素。unordered_map便是采用这种数据结构实现，unordered _map与map的使用基本一样，都是key/value之间的映射，只是他们内部采用的数据结构不一样。</p><blockquote><p>由于unordered_map内部是用散列表来实现快速查找，因此其内部元素完全是一种无序状态。哈希表利用哈希函数，将关键字的哈希值放都一个桶(bucket)里面，具有相同哈希值的放入到同一个桶。</p></blockquote><h2 id="头文件：-include"><a href="#头文件：-include" class="headerlink" title="头文件：#include "></a>头文件：#include <unordered_map></unordered_map></h2><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; stringmap;</span><br><span class="line"></span><br><span class="line">stringmap first;  <span class="comment">// empty</span></span><br><span class="line"><span class="function">stringmap <span class="title">second</span><span class="params">(&#123;&#123;<span class="string">"apple"</span>, <span class="string">"red"</span>&#125;,&#123;<span class="string">"lemon"</span>, <span class="string">"yellow"</span>&#125;&#125;)</span></span>;  <span class="comment">// init list</span></span><br><span class="line"><span class="function">stringmap <span class="title">third</span><span class="params">(&#123;&#123;<span class="string">"orange"</span>, <span class="string">"orange"</span>&#125;,&#123;<span class="string">"strawberry"</span>, <span class="string">"red"</span>&#125;&#125;)</span></span>;</span><br><span class="line"><span class="function">stringmap <span class="title">fourth</span><span class="params">(third)</span></span>;  <span class="comment">// copy</span></span><br><span class="line"><span class="function">stringmap <span class="title">fifth</span><span class="params">(fourth.begin(), fourth.end())</span></span>;  <span class="comment">// range</span></span><br></pre></td></tr></table></figure><p>容器大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; second.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>获取元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; second[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>元素查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it = second.find(<span class="string">"banana"</span>);  <span class="comment">//返回查找到元素的iterator，如未查找到，返回end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != second.end())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">" "</span> &lt;&lt; (*it).second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>元素修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; second;</span><br><span class="line">second[<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">second[<span class="string">'b'</span>] = <span class="number">2</span>;</span><br><span class="line">second[<span class="string">'c'</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">second.erase ( second.begin() );      <span class="comment">// erasing by iterator</span></span><br><span class="line">second.erase (<span class="string">'a'</span>);             <span class="comment">// erasing by key</span></span><br><span class="line">second.erase ( second.find(<span class="string">'c'</span>), second.end() ); <span class="comment">// erasing by range</span></span><br><span class="line"></span><br><span class="line">second.clear();  <span class="comment">//清空</span></span><br><span class="line">second.swap(first);   <span class="comment">//互换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.bucket_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//返回桶的数量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.bucket_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//返回每个桶的大小</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; second.bucket(<span class="string">'a'</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//返回当前元素在哪个桶</span></span><br><span class="line">second.rehash(<span class="number">10</span>);   <span class="comment">//设置桶的数量</span></span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>unordered_map内部使用哈希表进行存储与搜索。由于需要使用hash来进行映射，因此需要判断两个关键字是否相等，对于内部类型，可以直接进行判断，如果是用户自定义类型，则需要重载”==”运算符，指定如何判断两个关键字是否相等。以下是在网上摘录的一段代码，个人觉得比较详细的unordered_map的使用方法，这里只是其中一种使用方法：利用函数对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name =  name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the object of hash function */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonHash</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Person&amp; per) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(per.name) ^ hash&lt;<span class="keyword">int</span>&gt;()(per.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the object of compare */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonCmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; personA, <span class="keyword">const</span> Person&amp; personB)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personA.name == personB.name &amp;&amp; personA.age == personB.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* define the unordered_map type */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;Person, <span class="keyword">int</span>, PersonHash, PersonCmp&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">umap m;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom1"</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Tom2"</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"Tom3"</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"Tom4"</span>,<span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"Tom5"</span>,<span class="number">24</span>)</span></span>;</span><br><span class="line">m.insert(umap::value_type(p3, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p4, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p5, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p1, <span class="number">100</span>));</span><br><span class="line">m.insert(umap::value_type(p2, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里打印出来的顺序于插入顺序并不相同，确切的说是完全无序的 */</span></span><br><span class="line"><span class="keyword">for</span>(umap::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iter-&gt;first.name &lt;&lt; <span class="string">"\t"</span> &lt;&lt; iter-&gt;first.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;版权声明：本文为CSDN博主「Cypress1010」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/Cypress1010/arti
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="unordered_map" scheme="http://haokailong.top/tags/unordered-map/"/>
    
      <category term="STL" scheme="http://haokailong.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>cin, cin.getline(), getline()的用法</title>
    <link href="http://haokailong.top/2021/03/28/cin-cin-getline-getline-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://haokailong.top/2021/03/28/cin-cin-getline-getline-的用法/</id>
    <published>2021-03-28T13:38:20.000Z</published>
    <updated>2021-03-28T13:58:09.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-cin"><a href="#1-cin" class="headerlink" title="1. cin"></a>1. cin</h1><p>用法1：输入一个数字或字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a,b;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法2：接收一个字符串，遇“空格”、“TAB”、“回车”就结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：hello<br>输出：hello</p><p>输入：hello world<br>输出：hello</p></blockquote><h1 id="2-cin-getline"><a href="#2-cin-getline" class="headerlink" title="2. cin.getline()"></a>2. cin.getline()</h1><p>用法:接收一个字符串，可以接收空格并输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> m[<span class="number">20</span>];</span><br><span class="line">     <span class="built_in">cin</span>.getline(m,<span class="number">5</span>);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>输入：hello world<br>输出：hell</p></blockquote><p><strong>接收5个字符到m中，其中最后一个为’\0’，所以只看到4个字符输出；</strong></p><p>如果把5改成20：</p><blockquote><p>输入：hello world<br>输出：hello world</p></blockquote><p>延伸：<br>1、cin.getline()实际上有三个参数，<strong>cin.getline(接收字符串的变量,接收字符个数,结束字符)</strong><br>2、当第三个参数省略时，系统默认为’\0’<br>3、如果将例子中<strong>cin.getline()改为cin.getline(m,5,’a’)</strong>;当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk</p><h1 id="3-getline"><a href="#3-getline" class="headerlink" title="3. getline()"></a>3. getline()</h1><p>用法：接收一个字符串，可以接收空格并输出，需包含<code>#include&lt;string&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：hello world<br>输出：hello world</p></blockquote><h1 id="4-注意的问题"><a href="#4-注意的问题" class="headerlink" title="4. 注意的问题"></a>4. 注意的问题</h1><p>1、<strong>cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数</strong></p><p>2、当同时使用 <strong>cin ,  getline()</strong> 时，需要注意的是，在cin输入流完成之后，getline()之前，需要通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"\n"</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br></pre></td></tr></table></figure><p>的方式将<strong>回车符</strong>作为输入流cin以清除缓存，如果不这样做的话，在控制台上就不会出现getline()的输入提示，而直接跳过，因为程序默认地将之前的变量作为输入流。</p><p>看下面一段程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//standard input(cin)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter an integer value as your age: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;age;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Your ager is: "</span>&lt;&lt;age&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line">    <span class="comment">//cin and string</span></span><br><span class="line">    <span class="built_in">string</span> mystr;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"What's your name? "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    mystr=<span class="string">"\n"</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    </span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello,"</span>&lt;&lt;mystr&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter a F or M as your sex: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;sex;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Your sex is: "</span>&lt;&lt;sex&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"What's your favorite team? "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    mystr=<span class="string">"\n"</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="comment">///////////////////////////</span></span><br><span class="line">    </span><br><span class="line">    getline(<span class="built_in">cin</span>,mystr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I like "</span>&lt;&lt;mystr&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>Please enter an integer value as your age: 17<br>Your ager is: 17.<br>What’s your name?<br>Kevin<br>Hello,Kevin.<br>Please enter a F or M as your sex: M<br>Your sex is: M<br>What’s your favorite team? Rocket<br>I like Rocket.<br>请按任意键继续. . .</p></blockquote><p>如果不添加<code>///////////////////////////</code>之间的代码，运行结果为：</p><blockquote><p>Please enter an integer value as your age: 17<br>Your ager is: 17.<br>What’s your name?<br>Hello,.<br>Please enter a F or M as your sex: M<br>Your sex is: M<br>What’s your favorite team? I like .<br>请按任意键继续. . .</p></blockquote><p>其实<code>mystr = &#39;\n&#39;</code>可以去掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-cin&quot;&gt;&lt;a href=&quot;#1-cin&quot; class=&quot;headerlink&quot; title=&quot;1. cin&quot;&gt;&lt;/a&gt;1. cin&lt;/h1&gt;&lt;p&gt;用法1：输入一个数字或字符&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a,b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;a+b&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用法2：接收一个字符串，遇“空格”、“TAB”、“回车”就结束&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：hello&lt;br&gt;输出：hello&lt;/p&gt;
&lt;p&gt;输入：hello world&lt;br&gt;输出：hello&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;2-cin-getline&quot;&gt;&lt;a href=&quot;#2-cin-getline&quot; class=&quot;headerlink&quot; title=&quot;2. cin.getline()&quot;&gt;&lt;/a&gt;2. cin.getline()&lt;/h1&gt;&lt;p&gt;用法:接收一个字符串，可以接收空格并输出&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; m[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;.getline(m,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="ACM" scheme="http://haokailong.top/tags/ACM/"/>
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="OJ" scheme="http://haokailong.top/tags/OJ/"/>
    
      <category term="cin" scheme="http://haokailong.top/tags/cin/"/>
    
      <category term="getline" scheme="http://haokailong.top/tags/getline/"/>
    
      <category term="C" scheme="http://haokailong.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>scanf输入字符型BUG</title>
    <link href="http://haokailong.top/2021/03/28/scanf%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E5%9E%8BBUG/"/>
    <id>http://haokailong.top/2021/03/28/scanf输入字符型BUG/</id>
    <published>2021-03-28T11:30:23.000Z</published>
    <updated>2021-03-28T11:44:21.032Z</updated>
    
    <content type="html"><![CDATA[<p>问题原因是：<strong>键盘缓冲区残余信息</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a); </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a=%d     c=%c/n"</span>,a,c); </span><br><span class="line">    &#125;<span class="keyword">while</span>(c!=<span class="string">'N'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scanf(&quot;%c&quot;, &amp;c);</code>这句不能正常接收字符,什么原因呢？</p><p>我们用<code>printf(&quot;c=%d\n&quot;,c);</code>将c用int表示出来，看看scanf()函数赋给C到底是什么，结果是 c=10, ASCII值为10</p><p>是什么？换行即<code>\n</code>.</p><p>对了，我们每击打一下”Enter”键，向键盘缓冲区发去一个“回车”(\r),一个“换行”(\n),在这里\r被scanf()函数处理掉了（姑且这么认为吧^_^），而\n被scanf()函数“错误”地赋给了c.</p><p>解决办法：</p><ul><li>可以在两个scanf()函数之后加个fflush(stdin);</li><li>还有加getch(); </li><li>getchar();也可以</li></ul><p>但是要视具体scanf()语句加那个，这里就不分析了。但是加fflush(stdin);不管什么情况都可行。</p><h4 id="scanf-quot-c-quot-是会读入空格以及换行的，所以使用时一定要慎重。"><a href="#scanf-quot-c-quot-是会读入空格以及换行的，所以使用时一定要慎重。" class="headerlink" title="scanf(&quot;%c&quot;)是会读入空格以及换行的，所以使用时一定要慎重。"></a><code>scanf(&quot;%c&quot;)</code>是会读入空格以及换行的，所以使用时一定要慎重。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题原因是：&lt;strong&gt;键盘缓冲区残余信息&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="C" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="scanf" scheme="http://haokailong.top/tags/scanf/"/>
    
      <category term="getchar" scheme="http://haokailong.top/tags/getchar/"/>
    
  </entry>
  
  <entry>
    <title>ACM输入输出</title>
    <link href="http://haokailong.top/2021/03/28/ACM%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://haokailong.top/2021/03/28/ACM输入输出/</id>
    <published>2021-03-28T09:18:22.000Z</published>
    <updated>2021-03-28T15:30:19.180Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的笔试中，由于不熟悉ACM模式的输入输出，吃了大亏！所以在此总结和学习，吃一堑长一智。</p><blockquote><p>版权声明：本文为CSDN博主「yang1young」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qiao1245/article/details/53020326" target="_blank" rel="noopener">https://blog.csdn.net/qiao1245/article/details/53020326</a></p></blockquote><h1 id="1-C-输入"><a href="#1-C-输入" class="headerlink" title="1. C++输入"></a>1. C++输入</h1><h2 id="1-1-只有一组测试数据"><a href="#1-1-只有一组测试数据" class="headerlink" title="1.1. 只有一组测试数据"></a>1.1. 只有一组测试数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; iostream &gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a,b; </span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-有多组测试数据，直到读至输入文件结尾为止"><a href="#1-2-有多组测试数据，直到读至输入文件结尾为止" class="headerlink" title="1.2. 有多组测试数据，直到读至输入文件结尾为止"></a>1.2. 有多组测试数据，直到读至输入文件结尾为止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; iostream &gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a,b;</span><br><span class="line">       <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-在开始的时候输入一个N，接下来是N组数据"><a href="#1-3-在开始的时候输入一个N，接下来是N组数据" class="headerlink" title="1.3. 在开始的时候输入一个N，接下来是N组数据"></a>1.3. 在开始的时候输入一个N，接下来是N组数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志"><a href="#1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志" class="headerlink" title="1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志"></a>1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志</h2><p>例如A+B，题目中说明以<code>0, 0</code>结束输入，可以按照以下写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &amp;&amp; (a || b)) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-重定向输入，保存历史"><a href="#1-5-重定向输入，保存历史" class="headerlink" title="1.5. 重定向输入，保存历史"></a>1.5. 重定向输入，保存历史</h2><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"input.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);  <span class="comment">// 输入将被重定向到文件</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码从文件<font color="orange">“input.txt”</font>中读取输入，然后计算后输入到标准输出。</p><p>也可以用<code>freopen</code>函数将标准输出重定向到文件，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  freopen (<span class="string">"output.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"This sentence is redirected to a file.\n"</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello freopen function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fclose (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文件<font color="orange">“output.txt”</font>中显示为：</p><blockquote><p>This sentence is redirected to a file.</p><p>hello freopen function</p></blockquote><h2 id="1-6-输入字符串"><a href="#1-6-输入字符串" class="headerlink" title="1.6. 输入字符串"></a>1.6. 输入字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.getline(buf, <span class="number">255</span>)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中读入字符串通常使用cin.getline函数，可以接受用户的输入的字符，直到已达指定个数，或者用户输入了特定的字符。它的函数声明形式（函数原型）如下：</p><blockquote><p>istream&amp; getline(char line[], int size, char endchar= ‘\n’);<br>char line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。<br>int size : 最多接受几个字符，用户超过size的输入都将不被接受。<br>char endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。</p></blockquote><p><strong>使用<code>getline()</code>函数读取字符串，字符串中可以包含空格</strong></p><p>另一种读取字符串的方式是使用string，但是这种方式是无法读入空格的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; buf) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><blockquote><p>hello world</p></blockquote><p>输出：</p><blockquote><p>hello</p><p>world</p></blockquote><p>默认按照空格进行了切分，读入了两个字符串。</p><h1 id="2-C-输出"><a href="#2-C-输出" class="headerlink" title="2. C++输出"></a>2. C++输出</h1><p>输出有不同的格式要求，不注意的话经常会出现 <code>Presentation Error</code>，而且 PC2 很多时候还判断不出来输出格式错误，就简单的判为 <code>Wrong Answer</code>，所以输出格式一定要注意。</p><h3 id="1、一组输出接着一组输出，中间没有空行"><a href="#1、一组输出接着一组输出，中间没有空行" class="headerlink" title="1、一组输出接着一组输出，中间没有空行"></a>1、一组输出接着一组输出，中间没有空行</h3><p>这也是最简单的，请看题目 <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1010" target="_blank" rel="noopener">SDUT 1010</a>。</p><p>C 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每输出一组结果换行就可以了。</p><h3 id="2、一组接着一组，每一组后面有一空行"><a href="#2、一组接着一组，每一组后面有一空行" class="headerlink" title="2、一组接着一组，每一组后面有一空行"></a>2、一组接着一组，每一组后面有一空行</h3><p>请看题目 <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1016" target="_blank" rel="noopener">SDUT 1016</a>。</p><p>C 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n\n"</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每输出一组结果后输出两个换行就可以了。</p><h3 id="3、一组接着一组，每两组之间有一个空行"><a href="#3、一组接着一组，每两组之间有一个空行" class="headerlink" title="3、一组接着一组，每两组之间有一个空行"></a>3、一组接着一组，每两组之间有一个空行</h3><p>注意与前一种区分开，请看题目 <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1017" target="_blank" rel="noopener">SDUT 1017</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, sum, a;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">        <span class="keyword">if</span> (i != n - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否到达最后一组测试数据了，如果不是最后一组测试数据就多输出一个换行。</p><p><strong><em>很多题目都要求在输出数据的恰当位置加空行。一个空行就是一个单独的”\n”。这里，有的题目说：“After each test case, you should output one blank line”，而有的题目说：“Between each test case, you should ouput one blank line”。要注意After和Between的区别，因为如果多了一或少了空行，将导致Presentation Error甚至Wrong Answer。</em></strong></p><h1 id="3-C语言输入输出"><a href="#3-C语言输入输出" class="headerlink" title="3. C语言输入输出"></a>3. C语言输入输出</h1><p>有时候C++的输入输出可能太慢，不妨使用C语言的输入输出</p><p>主要方法有：</p><blockquote><p>printf ();//把键盘中的各类数据,加以格式控制输出到显示器屏幕上;<br>scanf ();//从键盘上输入各类数据,并存放到程序变量中;<br>puts ()://把数组变量中的一个字符串常量输出到显示器屏幕上;<br>gets ()://从键盘上输入一个字符串常量并放到程序的数组中;<br>putchar ()://把变量中的一个字符常量输出到显示器屏幕上;<br>getchar ()://从键盘上输入一个字符常量,此常量就是该函数的值;<br>sscanf()://从一个字符串中提取各类数据。</p></blockquote><h2 id="3-1-printf"><a href="#3-1-printf" class="headerlink" title="3.1. printf"></a>3.1. printf</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C Programming\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Number = %d\n"</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number1 = %f\n"</span>, <span class="number">13.5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number2 = %f\n"</span>, <span class="number">12.4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"character = %c\n"</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>C Programming<br>Number = 5<br>number1 = 13.500000<br>number2 = 12.400000<br>character = c</p></blockquote><h2 id="3-2-scanf"><a href="#3-2-scanf" class="headerlink" title="3.2. scanf"></a>3.2. scanf</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> num1;</span><br><span class="line"><span class="keyword">double</span> num2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;num1);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;num2);</span><br><span class="line"></span><br><span class="line">fflush(<span class="built_in">stdin</span>);  <span class="comment">// 清除缓冲区 </span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%f"</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num = %d\n"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num1 = %f\n"</span>, num1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num2 = %lf\n"</span>, num2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"character = %c\n"</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"multiple values = %d, %f"</span>, a, b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>num = 15<br>num1 = 1.200000<br>num2 = 3.560000<br>character = z<br>multiple values = 7, 7.770000</p></blockquote><h2 id="3-3-puts-gets"><a href="#3-3-puts-gets" class="headerlink" title="3.3. puts, gets"></a>3.3. puts, gets</h2><p><code>gets()</code>与<code>scanf(&quot;%s&quot;)</code>均可用于读取字符串。</p><p>1.不同点：</p><p>scanf不能接受空格、制表符Tab、回车等；</p><p><strong>而gets能够接受空格、制表符Tab和回车等；</strong></p><p>scanf ：当遇到回车，空格和tab键会自动在字符串后面添加’\0’，但是回车，空格和tab键仍会留在输入的缓冲区中。</p><p><strong>gets：可接受回车键之前输入的所有字符，并用’\0’替代 ‘\n’.回车键不会留在输入缓冲区中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入: hello world</p><p>输出: hello</p></blockquote><p>从键盘输入字符串<code>hello world</code>时，遇到空格，scanf()就认为输入结束了，所以buf中存放的字符串是 ‘hello\0’。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a中保存的字符串为：%s\n"</span>,a);</span><br><span class="line">    c=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c中保存的字符为：%c "</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入asdf回车，<strong>因为scanf会将回车保留在缓冲区中，所以回车会紧接着被c取得而不需要再额外输入，所以a中存储的是’asdf\0’，字符c=’\n’</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    gets(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b中保存的字符串为：%s\n"</span>,b);</span><br><span class="line">    d=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d中保存的字符为：%c"</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着输入<code>as df</code>回车，因为gets会将’\n’替换成’\0’，所以b字符串中保留的是<code>’as df\0’</code>，并且还是要继续输入d的值。</p><p><strong><code>printf()</code>与<code>puts()</code>不同点：</strong><br>puts（）在输出字符串时会将’\0’自动转换成’\n’进行输出，也就是说，puts方法输出完字符串后会自动换行。</p><h2 id="3-4-putchar-getchar"><a href="#3-4-putchar-getchar" class="headerlink" title="3.4. putchar, getchar"></a>3.4. putchar, getchar</h2><p><code>putchar()</code>是put character的缩写。作用是输出<strong>一个</strong>字符的值。</p><p>向计算机输入一个字符可以调用<code>getchar()</code>函数。</p><font color="orange">**强烈建议输入字符时均使用`getchar()`代替`scanf("%c")`，避免出现意想不到的BUG**</font><h2 id="3-5-sscanf"><a href="#3-5-sscanf" class="headerlink" title="3.5. sscanf"></a>3.5. sscanf</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure><p>从字符串读取格式化输入。</p><p>sscanf用法跟scanf差不多，只不过scanf是从标准输入stdin中读入，而sscanf函数是从指定的字符串中读取。相比scanf函数，sscanf函数多了第一个参数，传入一个字符串。</p><p><strong>取指定长度的字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">"123456"</span>,<span class="string">"%3s"</span>,str);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>123</p></blockquote><p><strong>将表示数字的字符串转换成整型变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">"123456"</span>, <span class="string">"%d"</span>, &amp;res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>123456</p></blockquote><p><strong>取需要的字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year,month,day;</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">"2017.12.5"</span>,<span class="string">"%d.%d.%d"</span>,&amp;year,&amp;month,&amp;day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"year:%d,month:%d,day:%d\n"</span>,year,month,day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>year:2017,month:12,day:5</p></blockquote><h2 id="3-6-带格式化的字符串输出"><a href="#3-6-带格式化的字符串输出" class="headerlink" title="3.6. 带格式化的字符串输出"></a>3.6. 带格式化的字符串输出</h2><p>有些题目要求输出这样的字符串：<code>abc*****de****f</code>，其中“*”代表空格。<br>要求是这样的：str1在前5个字符中左对齐，str2在第6到第10个字符中右对齐，str3在第11到第15个字符中右对齐。<br>可行的做法是，先初始化一个数组，用’ ‘（空格）填充，再在相应的位置填相应的内容。用程序来表述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>, str2[] = <span class="string">"de"</span>, str3[] = <span class="string">"f"</span>;</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">' '</span>, <span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">// 用空格填充</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%s"</span>, str1);</span><br><span class="line">str[<span class="built_in">strlen</span>(str1)] = <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str + <span class="number">5</span>, <span class="string">"%5s"</span>, str2);</span><br><span class="line">str[<span class="number">10</span>] = <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str + <span class="number">10</span>, <span class="string">"%5s"</span>, str3);</span><br><span class="line">str[<span class="number">15</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><p>关键的部分：<br>（1）在调用sprintf后，要清除不恰当字符串结束符（第5,7行）；<br>（2）在恰当的位置添加字符串结束符（第9行）。</p><h2 id="3-7-二维数组的输出"><a href="#3-7-二维数组的输出" class="headerlink" title="3.7. 二维数组的输出"></a>3.7. 二维数组的输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="blue">**注意每行最后不要多输出1个空格**</font><h1 id="4-格式化"><a href="#4-格式化" class="headerlink" title="4. 格式化"></a>4. 格式化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%d  以十进制形式输出带符号整数(正数不输出符号)   </span><br><span class="line">%o  以八进制形式输出无符号整数(不输出前缀O)   </span><br><span class="line">%x  以十六进制形式输出无符号整数(不输出前缀OX)   </span><br><span class="line">%u  以十进制形式输出无符号整数   </span><br><span class="line">%f  以小数形式输出单精度实数   </span><br><span class="line">%lf 以小数形式输出双精度实数 </span><br><span class="line">%e  以指数形式输出单、双精度实数   </span><br><span class="line">%g  以%f%e中较短的输出宽度输出单、双精度实数   </span><br><span class="line">%c  输出单个字符   </span><br><span class="line">%s  输出字符串</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> a = <span class="number">125.78</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%e\n"</span>, a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>125.779999<br>1.257800e+002</p></blockquote><h2 id="4-1-C语言精度控制"><a href="#4-1-C语言精度控制" class="headerlink" title="4.1. C语言精度控制"></a>4.1. C语言精度控制</h2><p>精度格式符以“.”开头，后跟十进制整数。意义是：如果输出数字，则表示小数的位数；如果输出的是字符， 则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> a = <span class="number">1.1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, a);  <span class="comment">// 保留两位小数，补齐</span></span><br><span class="line"><span class="keyword">double</span> b = <span class="number">123456789.456</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, b);  <span class="comment">// 保留两位小数，截断</span></span><br><span class="line"><span class="keyword">double</span> c=<span class="number">24212345.24232</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%020.4f\n"</span>, c);  <span class="comment">// 保留四位小数，输出占20位，若有空余的位补0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>1.10<br>123456789.46<br>000000024212345.2423</p></blockquote><h2 id="4-2-C-精度控制"><a href="#4-2-C-精度控制" class="headerlink" title="4.2. C++精度控制"></a>4.2. C++精度控制</h2><p>(只作了解，在笔试具体使用时，还是要用<code>printf()</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> num = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><p>1 设置对齐方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>1.25</p></blockquote><p>2 设置输出宽度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>​    1.25</p></blockquote><p>3 将宽度多余的部分用某个字符（如：’0’）填充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>00001.25</p></blockquote><p>4 设置精度：保留**位有效数字，如果小数点最后面有0，则自动去掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>); <span class="comment">//设置输出精度，保留有效数字</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>000001.2</p></blockquote><p>5 保留小数点后**位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span>.flags(ios::fixed);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">4</span>); <span class="comment">//设置输出精度，</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>001.2500</p></blockquote><p>6 保留小数点后有效的位数。如：1.25 保留4位有效数字后的1.250中0的显示，要依靠cout.setf(ios::showpoint)函数（因为保留有效数字的函数不会保留没用的0有效位）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::right); <span class="comment">// 设置对齐方式</span></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>); <span class="comment">//设置输出宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); <span class="comment">//将多余的空格用0填充</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::showpoint); <span class="comment">//将小数精度后面的0显示出来</span></span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">4</span>); <span class="comment">//设置输出精度，保留有效数字</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>0001.250</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的笔试中，由于不熟悉ACM模式的输入输出，吃了大亏！所以在此总结和学习，吃一堑长一智。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为CSDN博主「yang1young」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/qiao1245/article/details/53020326&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qiao1245/article/details/53020326&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-C-输入&quot;&gt;&lt;a href=&quot;#1-C-输入&quot; class=&quot;headerlink&quot; title=&quot;1. C++输入&quot;&gt;&lt;/a&gt;1. C++输入&lt;/h1&gt;&lt;h2 id=&quot;1-1-只有一组测试数据&quot;&gt;&lt;a href=&quot;#1-1-只有一组测试数据&quot; class=&quot;headerlink&quot; title=&quot;1.1. 只有一组测试数据&quot;&gt;&lt;/a&gt;1.1. 只有一组测试数据&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt; iostream &amp;gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a,b; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a+b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-2-有多组测试数据，直到读至输入文件结尾为止&quot;&gt;&lt;a href=&quot;#1-2-有多组测试数据，直到读至输入文件结尾为止&quot; class=&quot;headerlink&quot; title=&quot;1.2. 有多组测试数据，直到读至输入文件结尾为止&quot;&gt;&lt;/a&gt;1.2. 有多组测试数据，直到读至输入文件结尾为止&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt; iostream &amp;gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a,b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a+b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-3-在开始的时候输入一个N，接下来是N组数据&quot;&gt;&lt;a href=&quot;#1-3-在开始的时候输入一个N，接下来是N组数据&quot; class=&quot;headerlink&quot; title=&quot;1.3. 在开始的时候输入一个N，接下来是N组数据&quot;&gt;&lt;/a&gt;1.3. 在开始的时候输入一个N，接下来是N组数据&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, b, n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (n--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志&quot;&gt;&lt;a href=&quot;#1-4-输入不说明有多少组数据，但以某个特殊输入为结束标志&quot; class=&quot;headerlink&quot; title=&quot;1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志&quot;&gt;&lt;/a&gt;1.4. 输入不说明有多少组数据，但以某个特殊输入为结束标志&lt;/h2&gt;&lt;p&gt;例如A+B，题目中说明以&lt;code&gt;0, 0&lt;/code&gt;结束输入，可以按照以下写法：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;amp;&amp;amp; (a || b)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-5-重定向输入，保存历史&quot;&gt;&lt;a href=&quot;#1-5-重定向输入，保存历史&quot; class=&quot;headerlink&quot; title=&quot;1.5. 重定向输入，保存历史&quot;&gt;&lt;/a&gt;1.5. 重定向输入，保存历史&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="ACM" scheme="http://haokailong.top/tags/ACM/"/>
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="OJ" scheme="http://haokailong.top/tags/OJ/"/>
    
      <category term="iostream" scheme="http://haokailong.top/tags/iostream/"/>
    
  </entry>
  
  <entry>
    <title>整除3的最大和</title>
    <link href="http://haokailong.top/2021/03/28/%E6%95%B4%E9%99%A43%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://haokailong.top/2021/03/28/整除3的最大和/</id>
    <published>2021-03-28T09:06:14.000Z</published>
    <updated>2021-03-28T09:09:31.110Z</updated>
    
    <content type="html"><![CDATA[<p>对应于LeetCode. 1262. Greatest Sum Divisible by Three.</p><p>关键在于想到<code>模三取余</code>的操作。这道题及其变种是经常遇到的题目。</p><p>解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> **matrix = <span class="keyword">new</span> <span class="keyword">int</span>* [n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)  <span class="comment">// 初始化 </span></span><br><span class="line">   matrix[<span class="number">0</span>][j] = <span class="number">0</span>; </span><br><span class="line">matrix[<span class="number">0</span>][nums[<span class="number">0</span>]%<span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) </span><br><span class="line">        matrix[i][j] = matrix[i<span class="number">-1</span>][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[i] + matrix[i<span class="number">-1</span>][j];</span><br><span class="line">        matrix[i][sum%<span class="number">3</span>] = max(sum, matrix[i][sum%<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> matrix[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对应于LeetCode. 1262. Greatest Sum Divisible by Three.&lt;/p&gt;
&lt;p&gt;关键在于想到&lt;code&gt;模三取余&lt;/code&gt;的操作。这道题及其变种是经常遇到的题目。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Interview" scheme="http://haokailong.top/categories/Others/Interview/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="DP" scheme="http://haokailong.top/tags/DP/"/>
    
      <category term="动态规划" scheme="http://haokailong.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Dynamic Programming" scheme="http://haokailong.top/tags/Dynamic-Programming/"/>
    
      <category term="dp" scheme="http://haokailong.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch分布式训练-DistributedDataParallel</title>
    <link href="http://haokailong.top/2021/03/24/Pytorch%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83-DistributedDataParallel/"/>
    <id>http://haokailong.top/2021/03/24/Pytorch分布式训练-DistributedDataParallel/</id>
    <published>2021-03-24T12:51:04.000Z</published>
    <updated>2021-03-24T14:31:56.800Z</updated>
    
    <content type="html"><![CDATA[<p>与 DataParallel 的单进程控制多 GPU 不同，在 distributed 的帮助下，我们只需要编写一份代码，torch 就会自动将其分配给n个进程，分别在n个 GPU 上运行。</p><p>和单进程训练不同的是，多进程训练需要注意以下事项：</p><ul><li>在喂数据的时候，一个batch被分到了好几个进程，每个进程在取数据的时候要确保拿到的是不同的数据（<code>DistributedSampler</code>）；</li><li>要告诉每个进程自己是谁，使用哪块GPU（<code>args.local_rank</code>）；</li><li>在做BatchNormalization的时候要注意同步数据。</li></ul><h2 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1. 使用方式"></a>1. 使用方式</h2><h3 id="1-1-启动方式的改变"><a href="#1-1-启动方式的改变" class="headerlink" title="1.1. 启动方式的改变"></a>1.1. 启动方式的改变</h3><p>在多进程的启动方面，我们不用自己手写 multiprocess 进行一系列复杂的CPU、GPU分配任务，PyTorch为我们提供了一个很方便的启动器 <code>torch.distributed.launch</code> 用于启动文件，所以我们运行训练代码的方式就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=0,1,2,3 python -m torch.distributed.launch --nproc_per_node=4 main.py</span><br></pre></td></tr></table></figure><p>其中的 <code>--nproc_per_node</code> 参数用于指定为当前主机创建的进程数，由于我们是单机多卡，所以这里node数量为1，所以我们这里设置为所使用的GPU数量即可。</p><h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2. 初始化"></a>1.2. 初始化</h3><p>在启动器为我们启动python脚本后，在执行过程中，启动器会将当前进程的（其实就是 GPU的）index 通过参数传递给 python，我们可以这样获得当前进程的 index：即通过参数 <code>local_rank</code> 来告诉我们<strong>当前进程使用的是哪个GPU</strong>，用于我们在每个进程中指定不同的device：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--local_rank'</span>, type=int, default=<span class="number">0</span>，help=<span class="string">'node rank for distributed training'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    args = parse()</span><br><span class="line">    torch.cuda.set_device(args.local_rank)</span><br><span class="line">    torch.distributed.init_process_group(</span><br><span class="line">        <span class="string">'nccl'</span>,</span><br><span class="line">        init_method=<span class="string">'env://'</span></span><br><span class="line">    )</span><br><span class="line">    device = torch.device(<span class="string">f'cuda:<span class="subst">&#123;args.local_rank&#125;</span>'</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中 torch.distributed.<strong>init_process_group</strong> 用于<strong>初始化GPU通信方式（NCCL）和参数的获取方式（env代表通过环境变量）</strong>。使用 init_process_group 设置GPU之间通信使用的后端和端口，通过 NCCL 实现 GPU 通信。</p><h3 id="1-3-DataLoader"><a href="#1-3-DataLoader" class="headerlink" title="1.3. DataLoader"></a>1.3. DataLoader</h3><p>在读取数据的时候，我们要保证一个batch里的数据<strong>被均摊到每个进程上</strong>，每个进程都能获取到不同的数据，但如果我们手动去告诉每个进程拿哪些数据的话太麻烦了，PyTorch也为我们封装好了这一方法。之后，使用 <strong>DistributedSampler 对数据集进行划分</strong>。如此前我们介绍的那样，它能帮助我们将每个 batch 划分成几个 partition，在当前进程中只需要获取和 rank 对应的那个 partition 进行训练。</p><p>所以我们在初始化 <code>data loader</code> 的时候需要使用到 <code>torch.utils.data.distributed.DistributedSampler</code> 这个特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_sampler = torch.utils.data.distributed.DistributedSampler(train_dataset)</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=..., sampler=train_sampler)</span><br></pre></td></tr></table></figure><p>这样就能给<strong>每个进程一个不同的 sampler</strong>，告诉每个<strong>进程自己分别取哪些数据</strong>。</p><h3 id="1-4-模型的初始化"><a href="#1-4-模型的初始化" class="headerlink" title="1.4. 模型的初始化"></a>1.4. 模型的初始化</h3><p>和 <code>nn.DataParallel</code> 的方式一样，我们对于模型的初始化也是简单的一句话就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank])</span><br></pre></td></tr></table></figure><p>使用 DistributedDataParallel 包装模型，它能帮助我们为不同 GPU 上求得的梯度进行 all reduce（即汇总不同 GPU 计算所得的梯度，并同步计算结果）。all reduce 后不同 GPU 中模型的梯度均为 all reduce 之前各 GPU 梯度的均值。</p><h3 id="1-5-同步Batch-Normalization"><a href="#1-5-同步Batch-Normalization" class="headerlink" title="1.5. 同步Batch Normalization"></a>1.5. 同步Batch Normalization</h3><p><a href="https://zhuanlan.zhihu.com/p/40496177" target="_blank" rel="noopener">为什么要同步BN？</a></p><p>现有的标准 Batch Normalization 因为使用数据并行（Data Parallel），是单卡的实现模式，只对单个卡上对样本进行归一化，相当于减小了批量大小（batch-size）（详见BN工作原理部分）。 对于比较消耗显存的训练任务时，往往单卡上的相对批量过小，影响模型的收敛效果。<strong>之前在我们在图像语义分割的实验中，Jerry和我就发现使用大模型的效果反而变差，实际上就是BN在作怪</strong>。 跨卡同步 Batch Normalization 可以使用全局的样本进行归一化，这样相当于‘增大‘了批量大小，这样训练效果不再受到使用 GPU 数量的影响。 最近在图像分割、物体检测的论文中，使用跨卡BN也会显著地提高实验效果，所以跨卡 BN 已然成为竞赛刷分、发论文的必备神器。</p><p><font color="red">可惜 PyTorch 并没有为我们实现这一功能</font>，在接下来的介绍中我们会在 <code>apex</code> 中看到这一功能。</p><h2 id="2-汇总"><a href="#2-汇总" class="headerlink" title="2. 汇总"></a>2. 汇总</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> DataParallel</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> distributed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(<span class="number">30000</span>, <span class="number">50</span>, padding_idx=<span class="number">0</span>)</span><br><span class="line">        self.linear = nn.Linear(<span class="number">50</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, ids, bag_labels, E1s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param ids: (sents, seq_len) &lt;- (8, 120)</span></span><br><span class="line"><span class="string">        :param bag_labels: (bags, class_num) &lt;- (3, 2)</span></span><br><span class="line"><span class="string">        :param E1s: (bags, variable) &lt;- (3, variable)</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">'ids '</span>, ids.shape)</span><br><span class="line">        print(<span class="string">'bag_labels '</span>, bag_labels.shape)</span><br><span class="line">        print(<span class="string">'E1s '</span>, E1s)</span><br><span class="line">        print(<span class="string">'============================='</span>)</span><br><span class="line">        x = self.embedding(ids)</span><br><span class="line">        x = x.mean(dim=<span class="number">1</span>)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Data, self).__init__()</span><br><span class="line">        self.x = torch.randint(<span class="number">0</span>, <span class="number">9999</span>, size=(<span class="number">1000</span>, <span class="number">120</span>))  <span class="comment"># 1000 samples</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_batch</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        ids = torch.stack(data, dim=<span class="number">0</span>)</span><br><span class="line">        bag_labels = torch.randint(<span class="number">0</span>, <span class="number">2</span>, size=(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">        E1s = [[<span class="number">15</span>, <span class="number">39</span>], [<span class="number">9537</span>], [<span class="number">1</span>, <span class="number">70</span>, <span class="number">5132</span>]]</span><br><span class="line">        <span class="keyword">return</span> ids, bag_labels, E1s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--local_rank'</span>, default=<span class="number">-1</span>, type=int,  <span class="comment"># 用于启动器告知当前进程GPU号</span></span><br><span class="line">                        help=<span class="string">'node rank for distributed training'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    distributed.init_process_group(<span class="string">"nccl"</span>)</span><br><span class="line">    torch.cuda.set_device(args.local_rank)</span><br><span class="line"></span><br><span class="line">    train_set = Data()</span><br><span class="line">    train_sampler = torch.utils.data.distributed.DistributedSampler(train_set)</span><br><span class="line">    train_loader = DataLoader(train_set, batch_size=<span class="number">8</span>, sampler=train_sampler, drop_last=<span class="literal">True</span>,</span><br><span class="line">                              collate_fn=train_set.generate_batch)</span><br><span class="line"></span><br><span class="line">    device = torch.device(args.local_rank)</span><br><span class="line">    model = Model().to(device)</span><br><span class="line">    model = DistributedDataParallel(model, device_ids=[args.local_rank])</span><br><span class="line"></span><br><span class="line">    optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line">    loss_func = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">"epoch &#123;&#125;"</span>.format(epoch))</span><br><span class="line">        <span class="keyword">for</span> step, data <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">            ids = data[<span class="number">0</span>].to(device)</span><br><span class="line">            bag_labels = data[<span class="number">1</span>].to(device)</span><br><span class="line">            E1s = data[<span class="number">2</span>]</span><br><span class="line">            logits = model(ids, bag_labels, E1s)</span><br><span class="line">            labels = torch.randint(<span class="number">0</span>, <span class="number">2</span>, size=(<span class="number">8</span>, )).cuda()</span><br><span class="line">            loss = loss_func(logits, labels)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br></pre></td></tr></table></figure><p>在使用时，调用 torch.distributed.launch 启动器启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1,2 python -m torch.distributed.launch --nproc_per_node=2 run.py</span><br></pre></td></tr></table></figure><h3 id="2-1-数据切分"><a href="#2-1-数据切分" class="headerlink" title="2.1. 数据切分"></a>2.1. 数据切分</h3><p>在实验时发现，使用<code>DistributedDataParallel</code>不会对数据进行切分，应该是与使用了多个进程有关。因此可以用于对数据要求比较苛刻的实验环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与 DataParallel 的单进程控制多 GPU 不同，在 distributed 的帮助下，我们只需要编写一份代码，torch 就会自动将其分配给n个进程，分别在n个 GPU 上运行。&lt;/p&gt;
&lt;p&gt;和单进程训练不同的是，多进程训练需要注意以下事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在喂数据的时候，一个batch被分到了好几个进程，每个进程在取数据的时候要确保拿到的是不同的数据（&lt;code&gt;DistributedSampler&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;要告诉每个进程自己是谁，使用哪块GPU（&lt;code&gt;args.local_rank&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;在做BatchNormalization的时候要注意同步数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-使用方式&quot;&gt;&lt;a href=&quot;#1-使用方式&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方式&quot;&gt;&lt;/a&gt;1. 使用方式&lt;/h2&gt;&lt;h3 id=&quot;1-1-启动方式的改变&quot;&gt;&lt;a href=&quot;#1-1-启动方式的改变&quot; class=&quot;headerlink&quot; title=&quot;1.1. 启动方式的改变&quot;&gt;&lt;/a&gt;1.1. 启动方式的改变&lt;/h3&gt;&lt;p&gt;在多进程的启动方面，我们不用自己手写 multiprocess 进行一系列复杂的CPU、GPU分配任务，PyTorch为我们提供了一个很方便的启动器 &lt;code&gt;torch.distributed.launch&lt;/code&gt; 用于启动文件，所以我们运行训练代码的方式就变成了这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CUDA_VISIBLE_DEVICES=0,1,2,3 python -m torch.distributed.launch --nproc_per_node=4 main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的 &lt;code&gt;--nproc_per_node&lt;/code&gt; 参数用于指定为当前主机创建的进程数，由于我们是单机多卡，所以这里node数量为1，所以我们这里设置为所使用的GPU数量即可。&lt;/p&gt;
&lt;h3 id=&quot;1-2-初始化&quot;&gt;&lt;a href=&quot;#1-2-初始化&quot; class=&quot;headerlink&quot; title=&quot;1.2. 初始化&quot;&gt;&lt;/a&gt;1.2. 初始化&lt;/h3&gt;&lt;p&gt;在启动器为我们启动python脚本后，在执行过程中，启动器会将当前进程的（其实就是 GPU的）index 通过参数传递给 python，我们可以这样获得当前进程的 index：即通过参数 &lt;code&gt;local_rank&lt;/code&gt; 来告诉我们&lt;strong&gt;当前进程使用的是哪个GPU&lt;/strong&gt;，用于我们在每个进程中指定不同的device：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="Pytorch" scheme="http://haokailong.top/tags/Pytorch/"/>
    
      <category term="DistributedDataParallel" scheme="http://haokailong.top/tags/DistributedDataParallel/"/>
    
  </entry>
  
  <entry>
    <title>DataParallel数据切分的方式</title>
    <link href="http://haokailong.top/2021/03/24/DataParallel%E6%95%B0%E6%8D%AE%E5%88%87%E5%88%86%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://haokailong.top/2021/03/24/DataParallel数据切分的方式/</id>
    <published>2021-03-24T12:36:55.000Z</published>
    <updated>2021-03-24T12:43:00.925Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用DataParallel时，需要仔细探讨Pytorch默认的数据划分方式，于是做个实验进行尝试。</p><p>先说结论：</p><h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1. 结论"></a>1. 结论</h2><ol><li>对于tensor型数据，平均划分；如果不能整除，从前到后补充</li><li>对于非tensor型数据，复制到每台设备</li></ol><a id="more"></a><h2 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> DataParallel</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(<span class="number">30000</span>, <span class="number">50</span>, padding_idx=<span class="number">0</span>)</span><br><span class="line">        self.linear = nn.Linear(<span class="number">50</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, ids, bag_labels, E1s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param ids: (sents, seq_len) &lt;- (8, 120)</span></span><br><span class="line"><span class="string">        :param bag_labels: (bags, class_num) &lt;- (3, 2)</span></span><br><span class="line"><span class="string">        :param E1s: (bags, variable) &lt;- (3, variable)</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"ids "</span>, ids.shape)</span><br><span class="line">        print(<span class="string">"bag_labels "</span>, bag_labels.shape)</span><br><span class="line">        print(<span class="string">"E1s "</span>, E1s)</span><br><span class="line">        print(<span class="string">'============================='</span>)</span><br><span class="line">        x = self.embedding(ids)</span><br><span class="line">        x = x.mean(dim=<span class="number">1</span>)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Data, self).__init__()</span><br><span class="line">        self.x = torch.randint(<span class="number">0</span>, <span class="number">9999</span>, size=(<span class="number">1000</span>, <span class="number">120</span>))  <span class="comment"># 1000 samples</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 设置可见显卡 (物理层)</span></span><br><span class="line">    os.environ[<span class="string">"CUDA_DEVICE_ORDER"</span>] = <span class="string">"PCI_BUS_ID"</span></span><br><span class="line">    os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"1, 2"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置并行显卡 (逻辑层)</span></span><br><span class="line">    device = torch.device(<span class="string">"cuda:0"</span>)</span><br><span class="line">    model = Model().to(device)  <span class="comment"># 发送到设备</span></span><br><span class="line">    model = DataParallel(model, device_ids=[<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 多卡训练</span></span><br><span class="line">    loader = DataLoader(Data(), batch_size=<span class="number">8</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">    optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> step, data <span class="keyword">in</span> enumerate(loader):</span><br><span class="line">            data = data.to(device)</span><br><span class="line">            bag_labels = torch.randint(<span class="number">0</span>, <span class="number">2</span>, size=(<span class="number">3</span>, <span class="number">2</span>)).to(device)</span><br><span class="line">            E1s = [[<span class="number">15</span>, <span class="number">39</span>], [<span class="number">9537</span>], [<span class="number">1</span>, <span class="number">70</span>, <span class="number">5132</span>]]</span><br><span class="line">            logits = model(data, bag_labels, E1s)</span><br><span class="line">            print(<span class="string">"step &#123;&#125;"</span>.format(step))</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">step 87</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([2, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([1, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">step 88</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([2, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">ids  torch.Size([4, 120])</span><br><span class="line">bag_labels  torch.Size([1, 2])</span><br><span class="line">E1s  [[15, 39], [9537], [1, 70, 5132]]</span><br><span class="line">=============================</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在使用DataParallel时，需要仔细探讨Pytorch默认的数据划分方式，于是做个实验进行尝试。&lt;/p&gt;
&lt;p&gt;先说结论：&lt;/p&gt;
&lt;h2 id=&quot;1-结论&quot;&gt;&lt;a href=&quot;#1-结论&quot; class=&quot;headerlink&quot; title=&quot;1. 结论&quot;&gt;&lt;/a&gt;1. 结论&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对于tensor型数据，平均划分；如果不能整除，从前到后补充&lt;/li&gt;
&lt;li&gt;对于非tensor型数据，复制到每台设备&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="Pytorch" scheme="http://haokailong.top/tags/Pytorch/"/>
    
      <category term="DataParallel" scheme="http://haokailong.top/tags/DataParallel/"/>
    
      <category term="tensor" scheme="http://haokailong.top/tags/tensor/"/>
    
  </entry>
  
  <entry>
    <title>CUDA_DEVICE_ORDER</title>
    <link href="http://haokailong.top/2021/03/24/CUDA-DEVICE-ORDER/"/>
    <id>http://haokailong.top/2021/03/24/CUDA-DEVICE-ORDER/</id>
    <published>2021-03-24T08:12:28.000Z</published>
    <updated>2021-03-24T08:46:33.508Z</updated>
    
    <content type="html"><![CDATA[<p>NVML工具nvidia-smi按设备的PCI Bus ID 为设备分配索引序号，由于PCI Bus ID 是硬件相关的，我们把设备的 PCI Bus ID 或者按该ID分配的索引号为物理ID。</p><p>CUDA应用运行时进行设备查询（比如deviceQuery）返回的设备ID可能与物理ID不一致，譬如下面这位网友遇到的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## NVML id 是 物理ID，CUDA index是CUDA应用查询返回的设备ID</span></span><br><span class="line">NVML id 0 maps to Cuda index 4</span><br><span class="line">NVML id 1 maps to Cuda index 5</span><br><span class="line">NVML id 2 maps to Cuda index 6</span><br><span class="line">NVML id 3 maps to Cuda index 7</span><br><span class="line">NVML id 4 maps to Cuda index 0</span><br><span class="line">NVML id 5 maps to Cuda index 1</span><br><span class="line">NVML id 6 maps to Cuda index 2</span><br><span class="line">NVML id 7 maps to Cuda index 3</span><br><span class="line">NVML id 8 maps to Cuda index 8</span><br><span class="line">NVML id 9 maps to Cuda index 9</span><br><span class="line">NVML id 10 maps to Cuda index 10</span><br><span class="line">NVML id 11 maps to Cuda index 11</span><br><span class="line">NVML id 12 maps to Cuda index 12</span><br><span class="line">NVML id 13 maps to Cuda index 13</span><br><span class="line">NVML id 14 maps to Cuda index 14</span><br><span class="line">NVML id 15 maps to Cuda index 15</span><br></pre></td></tr></table></figure><p>我们可以通过设置 CUDA_DEVICE_ORDER = PCI_BUS_ID 来要求运行时设备查询按照 PCI_BUS_ID 的顺序索引，从而使得  设备ID=物理ID  保证CUDA应用按期望使用指定设备。目前最佳的设置方法是同时设置 CUDA_DEVICE_ORDER = PCI_BUS_ID 和 CUDA_VISIBLE_DEVICES 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">"CUDA_DEVICE_ORDER"</span>] = <span class="string">"PCI_BUS_ID"</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"2, 3"</span></span><br></pre></td></tr></table></figure><p>当你添加这两行代码后，那么device_ids[0]默认的就是第2号卡，你的模型也会初始化在第2号卡上了，而不会占用第0号卡了。<strong>这里简单说一下设置上面两行代码后，那么对这个程序而言可见的只有2和3号卡，和其他的卡没有关系，这是物理上的号卡，逻辑上来说其实是对应0和1号卡，即device_ids[0]对应的就是第2号卡，device_ids[1]对应的就是第3号卡</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NVML工具nvidia-smi按设备的PCI Bus ID 为设备分配索引序号，由于PCI Bus ID 是硬件相关的，我们把设备的 PCI Bus ID 或者按该ID分配的索引号为物理ID。&lt;/p&gt;
&lt;p&gt;CUDA应用运行时进行设备查询（比如deviceQuery）返回
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="CUDA" scheme="http://haokailong.top/tags/CUDA/"/>
    
      <category term="CUDA_DEVICE_ORDER" scheme="http://haokailong.top/tags/CUDA-DEVICE-ORDER/"/>
    
      <category term="CUDA_VISIBLE_DEVICES" scheme="http://haokailong.top/tags/CUDA-VISIBLE-DEVICES/"/>
    
  </entry>
  
  <entry>
    <title>C++变长数组</title>
    <link href="http://haokailong.top/2021/03/23/C-%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84/"/>
    <id>http://haokailong.top/2021/03/23/C-变长数组/</id>
    <published>2021-03-23T05:06:58.000Z</published>
    <updated>2021-03-23T05:17:22.796Z</updated>
    
    <content type="html"><![CDATA[<p>之前在DEV C++中，对于变长数组，习惯采用以下写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[m][n];</span><br></pre></td></tr></table></figure><p>但是，在按照这种方式书写三维数组时，出现了内存错误。</p><p>查阅网上的博客，有这种说法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;  </span><br><span class="line">    <span class="comment">//用指针p指向new动态分配的长度为len*sizeof(int)的内存空间  </span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[len];  </span><br><span class="line">    <span class="comment">/*注意int *p = new int[len];这一句，你不能这样做：  </span></span><br><span class="line"><span class="comment">    int p[len];  </span></span><br><span class="line"><span class="comment">    C++编译器会报错说len的大小不能确定，因为用这种形式声明数组，数组的大小需要在编译时确定。</span></span><br><span class="line"><span class="comment">    而且这样也不行：</span></span><br><span class="line"><span class="comment">    int p[] = new int[len];  </span></span><br><span class="line"><span class="comment">    编译器会说不能把int*型转化为int[]型，因为用new开辟了一段内存空间后会返回这段内存的首地址，所以要把这个地址赋给一个指针，所以要用： </span></span><br><span class="line"><span class="comment">    int *p = new int[len]*/</span></span><br><span class="line">    <span class="keyword">delete</span>[] p; <span class="comment">//注意要注销指针p，使程序释放用new开辟的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>可能是因为编译器的版本不同。但是，按照<code>new</code>申请内存应该是一种最为规范的做法，在任何版本都不会出错。</p><h2 id="使用vector"><a href="#使用vector" class="headerlink" title="使用vector"></a>使用vector</h2><p>使用C++标准模版库（STL）中的vector（向量）也可以实现变长数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>(len); <span class="comment">// 声明变长数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在DEV C++中，对于变长数组，习惯采用以下写法：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[m][n];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，在按照这种方式书写三维数组时，出现了内存错误。&lt;/p&gt;
&lt;p&gt;查阅网上的博客，有这种说法：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; len;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//用指针p指向new动态分配的长度为len*sizeof(int)的内存空间  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[len];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*注意int *p = new int[len];这一句，你不能这样做：  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    int p[len];  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    C++编译器会报错说len的大小不能确定，因为用这种形式声明数组，数组的大小需要在编译时确定。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    而且这样也不行：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    int p[] = new int[len];  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    编译器会说不能把int*型转化为int[]型，因为用new开辟了一段内存空间后会返回这段内存的首地址，所以要把这个地址赋给一个指针，所以要用： &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    int *p = new int[len]*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt;[] p; &lt;span class=&quot;comment&quot;&gt;//注意要注销指针p，使程序释放用new开辟的内存空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://haokailong.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="array" scheme="http://haokailong.top/tags/array/"/>
    
      <category term="dynamic" scheme="http://haokailong.top/tags/dynamic/"/>
    
  </entry>
  
  <entry>
    <title>hexo error spawn failed解决办法</title>
    <link href="http://haokailong.top/2021/03/20/hexo-error-spawn-failed%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://haokailong.top/2021/03/20/hexo-error-spawn-failed解决办法/</id>
    <published>2021-03-20T04:07:42.000Z</published>
    <updated>2021-03-20T04:09:46.745Z</updated>
    
    <content type="html"><![CDATA[<p>出现错误：</p><p><code>error: spawn failed...</code></p><p>总结：</p><p>问题大多是因为<code>git</code>进行<code>push</code>或者<code>hexo d</code>的时候改变了一些<code>.deploy_git</code>文件下的内容。</p><p>解决办法：</p><ol><li>删除<code>.deploy_git</code>文件夹;</li><li>输入<code>git config --global core.autocrlf false</code></li><li>然后，依次执行：<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code></li></ol><p>问题解决。暴力直接，有效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;出现错误：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;error: spawn failed...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;问题大多是因为&lt;code&gt;git&lt;/code&gt;进行&lt;code&gt;push&lt;/code&gt;或者&lt;code&gt;hexo d&lt;/code&gt;的时候改变了一
      
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
    
      <category term="hexo" scheme="http://haokailong.top/tags/hexo/"/>
    
      <category term="git" scheme="http://haokailong.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ELECTRA预训练模型</title>
    <link href="http://haokailong.top/2021/03/19/ELECTRA%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <id>http://haokailong.top/2021/03/19/ELECTRA预训练模型/</id>
    <published>2021-03-19T13:13:12.000Z</published>
    <updated>2021-03-19T15:30:16.066Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ELECTRA详解：</p><p><a href="https://zhuanlan.zhihu.com/p/118135466" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/118135466</a></p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-93eaff2a96a1b7d2991417ba10aab35f_720w.jpg" alt></p><h2 id="1-创新点"><a href="#1-创新点" class="headerlink" title="1. 创新点"></a>1. 创新点</h2><ul><li>提出了新的模型预训练的框架，采用generator和discriminator的结合方式，但又不同于GAN</li><li>将Masked Language Model的方式改为了replaced token detection</li><li>因为masked language model 能有效地学习到context的信息，所以能很好地学习embedding，所以使用了weight sharing的方式将generator的embedding的信息共享给discriminator</li><li>dicriminator 预测了generator输出的每个token是不是original的，从而高效地更新transformer的各个参数，使得模型的熟练速度加快</li><li>该模型采用了小的generator以及discriminator的方式共同训练，并且采用了两者loss相加，使得discriminator的学习难度逐渐地提升，学习到更难的token（plausible tokens）</li><li>模型在fine-tuning 的时候，丢弃generator，只使用discrinator</li></ul><a id="more"></a><h2 id="2-模型架构"><a href="#2-模型架构" class="headerlink" title="2. 模型架构"></a>2. 模型架构</h2><p>BERT存在预训练和fine-tuning的mismatch，因为在fine-tuning阶段，并不会有[MASK]的token。</p><p>ELECTRA由两部分组成，分别是generator以及discriminator，两个都是transformer的encoder结构，只是两者的size不同：</p><ul><li><p>generator：就是一个小的 masked language model（通常是 1/4 的discriminator的size），该模块的具体作用是他采用了经典的bert的MLM方式：</p></li><li><ul><li>首先随机选取15%的tokens，替代为[MASK]token，（取消了bert的80%[MASK],10%unchange, 10% random replaced 的操作，具体原因也是因为没必要，因为我们finetuning使用的discriminator)</li><li>使用generator去训练模型，使得模型预测masked token，得到corrupted tokens</li><li>generator的目标函数和bert一样，都是希望被masked的能够被还原成原本的original tokens<br>如上图， token，<code>the</code> 和 <code>cooked</code> 被随机选为被masked，然后generator预测得到corrupted tokens，变成了<code>the</code>和<code>ate</code></li></ul></li></ul><ul><li><p>discriminator：discriminator的接收被generator corrupt之后的输入，discriminator的作用是分辨输入的每一个token是original的还是replaced，注意：如果generator生成的token和原始token一致，那么这个token仍然是original的</p></li><li><ul><li>所以，对于每个token，discriminator都会进行一个二分类，最后获得loss</li></ul></li></ul><p>以上的方式被称为replaced token detection。</p><ul><li>learn from all tokens (instead of 15%)</li><li>compute efficient</li><li>paramter efficient</li><li>improves downstream task performance</li></ul><h3 id="2-1-个人理解"><a href="#2-1-个人理解" class="headerlink" title="2.1. 个人理解"></a>2.1. 个人理解</h3><p>可以把generator看作之前任意一种预训练语言模型，如BERT, RoBERTa等，借鉴了GAN的思想。但是否同样存在训练困难的问题？例如generator性能足够好，导致discriminator输出均为<code>original</code>?</p><h2 id="3-如何训练"><a href="#3-如何训练" class="headerlink" title="3. 如何训练"></a>3. 如何训练</h2><p>该模型采用了minimize the combined loss的方式进行训练：</p><script type="math/tex; mode=display">\min_{\theta_G, \theta_D} \sum_{\vec{x} \in X} L_{MLM}(\vec{x},\theta_{G}) + \lambda L_{Dis}(\vec{x}, \theta_{D})</script><p>其中</p><p>$L<em>{MLM}(\vec{x}, \theta</em>{G})$对于输入$\vec{x} = [x_1, …, x_n]$，经过generator之后得到编码了上下文信息的vector representation，$h(\vec{x}) = [h_1,…,h_n]$，对于位置t，其被替换为[MASK]，那么它的output probability（经过softmax）为：</p><script type="math/tex; mode=display">p_G(x_t|\vec{x}) = \frac{\exp(\mathrm{e}(x_t)^T \cdot \mathrm{h_g}(\vec{x})_t)}{\sum_{x^{'}} \exp(\mathrm{e}(x^{'})^T \cdot \mathrm{h_g} (\vec{x})_t)}</script><p>其中$\mathrm{e}(x_t)$为单词的embedding表示，而$\mathrm{h_g}(\vec{x})_t$为经过generator之后的隐藏层表示。</p><p>然后计算交叉熵损失。</p><p><br></p><p>对于discriminator：</p><script type="math/tex; mode=display">D(\vec{x},t) = \mathrm{sigmoid} (w^Th_D(\vec{x})_t)</script><p>然后计算BCE (binary cross entropy) 损失。</p><h3 id="3-1-反向传播"><a href="#3-1-反向传播" class="headerlink" title="3.1. 反向传播"></a>3.1. 反向传播</h3><p><strong><em>在训练过程中，discriminator的loss不会反向传播到generator</em></strong>（因为generator的sampling的步骤导致）</p><font color="red">但是如果采用这种做法，是否generator存在的必要性就没有了？完全可以采用手动替换的方式，首先进行较为明显的替换，例如用动词替换名词。随着训练的进行，逐渐改为用BERT等预训练模型的预测结果作为替换，增大检测难度。emmm</font><h3 id="3-2-其他训练方式"><a href="#3-2-其他训练方式" class="headerlink" title="3.2. 其他训练方式"></a>3.2. 其他训练方式</h3><p>作者显然也考虑到这一点，在论文中提出了其他训练方式：</p><ul><li>一种是GAN：ELECTRA以一种对抗学习的思想来训练。作者将生成器的目标函数由最小化MLM loss换成了最大化判别器在被替换token上的loss。用强化学习Policy Gradient的思想，将被替换token的交叉熵作为生成器的reward，然后进行梯度下降。强化方法优化下来生成器在MLM任务上可以达到54%的准确率，而之前MLE优化下可以达到65%。</li><li>一种是two-stage 训练，先训练 $L_{MLM}$ n steps，然后froze住 generator，再训练 discriminator n steps<br>但是效果都没有共同训练效果好</li></ul><h2 id="4-超参数"><a href="#4-超参数" class="headerlink" title="4. 超参数"></a>4. 超参数</h2><p>文章中提到了，如果generator过强，那么discriminator就无法成功训练，这其实也很好理解。因为generator非常强，那么预测出来的token都非常好，即都是original tokens，那么discrinator 并不需要如何学习就收敛，因为它只需要把所有二分类都认为是1就行（假设1代表real）</p><p><img src="https://pic2.zhimg.com/80/v2-4b664f463f5c390806db89e3071fa8c5_720w.jpg" alt></p><p>我们可以发现，当generator的size 为discriminator size 的 1/2 到 1/4 时，模型效果最好。</p><p>由于ELECTRA是判别式任务，不用对每个位置的整个数据分布建模，所以更parameter-efficient。</p><ul><li>模型大小的因素</li></ul><p>可以从下图的实验结果看出，ELECTRA 模型在小模型的时候，效果提升显著，随着模型大小的增加，效果降低。</p><p>同时可以看到，在相同的计算量的时候，ELECTRA的效果优于BERT。</p><p><img src="https://pic4.zhimg.com/80/v2-0187b4b8e3777682833d952f2fe9bfd3_720w.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ELECTRA详解：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/118135466&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/118135466&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-93eaff2a96a1b7d2991417ba10aab35f_720w.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-创新点&quot;&gt;&lt;a href=&quot;#1-创新点&quot; class=&quot;headerlink&quot; title=&quot;1. 创新点&quot;&gt;&lt;/a&gt;1. 创新点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;提出了新的模型预训练的框架，采用generator和discriminator的结合方式，但又不同于GAN&lt;/li&gt;
&lt;li&gt;将Masked Language Model的方式改为了replaced token detection&lt;/li&gt;
&lt;li&gt;因为masked language model 能有效地学习到context的信息，所以能很好地学习embedding，所以使用了weight sharing的方式将generator的embedding的信息共享给discriminator&lt;/li&gt;
&lt;li&gt;dicriminator 预测了generator输出的每个token是不是original的，从而高效地更新transformer的各个参数，使得模型的熟练速度加快&lt;/li&gt;
&lt;li&gt;该模型采用了小的generator以及discriminator的方式共同训练，并且采用了两者loss相加，使得discriminator的学习难度逐渐地提升，学习到更难的token（plausible tokens）&lt;/li&gt;
&lt;li&gt;模型在fine-tuning 的时候，丢弃generator，只使用discrinator&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="http://haokailong.top/categories/NLP/"/>
    
      <category term="Pretrained Language Model" scheme="http://haokailong.top/categories/NLP/Pretrained-Language-Model/"/>
    
    
      <category term="PLM" scheme="http://haokailong.top/tags/PLM/"/>
    
      <category term="ELECTRA" scheme="http://haokailong.top/tags/ELECTRA/"/>
    
  </entry>
  
  <entry>
    <title>RoBERTa预训练模型</title>
    <link href="http://haokailong.top/2021/03/19/RoBERTa%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <id>http://haokailong.top/2021/03/19/RoBERTa预训练模型/</id>
    <published>2021-03-19T12:52:24.000Z</published>
    <updated>2021-03-19T13:12:45.528Z</updated>
    
    <content type="html"><![CDATA[<p>相比于BERT的调整：</p><ol><li>训练时间更长，batch size更大，训练数据更多</li><li>移除next sentence prediction loss</li><li>训练序列更长</li><li>动态mask机制</li></ol><p>BERT原型使用的是 character-level BPE vocabulary of size 30K, RoBERTa使用了GPT2的 BPE 实现，使用的是byte而不是unicode characters作为subword的单位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相比于BERT的调整：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;训练时间更长，batch size更大，训练数据更多&lt;/li&gt;
&lt;li&gt;移除next sentence prediction loss&lt;/li&gt;
&lt;li&gt;训练序列更长&lt;/li&gt;
&lt;li&gt;动态mask机制&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
    
      <category term="NLP" scheme="http://haokailong.top/categories/NLP/"/>
    
      <category term="Pretrained Language Model" scheme="http://haokailong.top/categories/NLP/Pretrained-Language-Model/"/>
    
    
      <category term="PLM" scheme="http://haokailong.top/tags/PLM/"/>
    
      <category term="RoBERTa" scheme="http://haokailong.top/tags/RoBERTa/"/>
    
      <category term="pretrained language models" scheme="http://haokailong.top/tags/pretrained-language-models/"/>
    
  </entry>
  
  <entry>
    <title>C++数组填充方法</title>
    <link href="http://haokailong.top/2021/03/19/C-%E6%95%B0%E7%BB%84%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95/"/>
    <id>http://haokailong.top/2021/03/19/C-数组填充方法/</id>
    <published>2021-03-19T06:36:34.000Z</published>
    <updated>2021-03-19T06:52:17.018Z</updated>
    
    <content type="html"><![CDATA[<p>在对数组初始化时，往往需要赋予同样的值，例如布尔型数组全部设为false</p><p>现在要把a里面1000个全部初始化为5；str里面全部初始化为a；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1000</span>] = &#123;<span class="string">'a'</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>但这样只有第一个元素被设置，其余999个自动默认是int 的0</strong>；</p><h1 id="1-memset"><a href="#1-memset" class="headerlink" title="1. memset"></a>1. memset</h1><p>首先，<strong>memset函数是逐字节进行填充</strong>，所以不适合int型数组。</p><p>对于字符型数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="built_in">memset</span>(str,<span class="string">'a'</span>,<span class="keyword">sizeof</span>(str))</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="2-fill"><a href="#2-fill" class="headerlink" title="2. fill"></a>2. fill</h1><p>按照单元赋值，将一个区间的元素都赋同一个值．<br>我们还是来看下实现吧：</p><blockquote><p>void fill(ForwardIt first, ForwardIt last, const T&amp; value);<br>void fill_n(OutputIt first, size n, const T&amp; value);<br>功能：<br>fill给迭代器范围[first, last)内元素均赋值为value。无返回值。<br>fill_n将first指向范围内的前n个元素赋值为value。返回first+n(c++11)</p></blockquote><p>对应的源代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">fill</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    *first = val;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><p>对于int a[1000]的批量填充：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">fill(a, a + <span class="number">1000</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h1 id="3-fill-n"><a href="#3-fill-n" class="headerlink" title="3. fill_n"></a>3. fill_n</h1><p>对应的源代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">fill_n</span> (<span class="title">OutputIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    *first = val;</span><br><span class="line">    ++first; --n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;     <span class="comment">// since C++11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">fill_n(a, <span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;　myvector (<span class="number">8</span>,<span class="number">10</span>); <span class="comment">// myvector: 10 10 10 10 10 10 10 10</span></span><br><span class="line">fill_n (myvector.begin(),<span class="number">4</span>,<span class="number">20</span>); <span class="comment">// myvector: 20 20 20 20 10 10 10 10</span></span><br><span class="line">fill_n (myvector.begin()+<span class="number">3</span>,<span class="number">3</span>,<span class="number">33</span>); <span class="comment">// myvector: 20 20 20 33 33 33 10 10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对数组初始化时，往往需要赋予同样的值，例如布尔型数组全部设为false&lt;/p&gt;
&lt;p&gt;现在要把a里面1000个全部初始化为5；str里面全部初始化为a；&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;但这样只有第一个元素被设置，其余999个自动默认是int 的0&lt;/strong&gt;；&lt;/p&gt;
&lt;h1 id=&quot;1-memset&quot;&gt;&lt;a href=&quot;#1-memset&quot; class=&quot;headerlink&quot; title=&quot;1. memset&quot;&gt;&lt;/a&gt;1. memset&lt;/h1&gt;&lt;p&gt;首先，&lt;strong&gt;memset函数是逐字节进行填充&lt;/strong&gt;，所以不适合int型数组。&lt;/p&gt;
&lt;p&gt;对于字符型数组：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(str,&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(str))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://haokailong.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="array" scheme="http://haokailong.top/tags/array/"/>
    
      <category term="memset" scheme="http://haokailong.top/tags/memset/"/>
    
      <category term="fill" scheme="http://haokailong.top/tags/fill/"/>
    
      <category term="fill_n" scheme="http://haokailong.top/tags/fill-n/"/>
    
  </entry>
  
  <entry>
    <title>python执行原理</title>
    <link href="http://haokailong.top/2021/03/17/python%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://haokailong.top/2021/03/17/python执行原理/</id>
    <published>2021-03-17T12:47:43.000Z</published>
    <updated>2021-03-17T12:59:31.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://blog.csdn.net/helloxiaozhe/article/details/78104975" target="_blank" rel="noopener">python编译过程和执行原理</a></p></blockquote><hr><h1 id="1-python执行原理"><a href="#1-python执行原理" class="headerlink" title="1. python执行原理"></a>1. python执行原理</h1><p>这里的解释执行是相对于编译执行而言的。我们都知道，使用C/C++之类的编译性语言编写的程序，是需要从源文件转换成计算机使用的机器语言，经过链接器链接之后形成了二进制的可执行文件。运行该程序的时候，就可以把二进制程序从硬盘载入到内存中并运行。</p><p>但是对于Python而言，python源码不需要编译成二进制代码，它可以直接从源代码运行程序。当我们运行python文件程序的时候，python解释器将源代码转换为字节码，然后再由python解释器来执行这些字节码。这样，python就不用担心程序的编译,库的链接加载等问题了。</p><p>对于python解释语言，有以下3方面的特性：</p><ol><li>每次运行都要进行转换成字节码，然后再有虚拟机把字节码转换成机器语言，最后才能在硬件上运行。与编译性语言相比，每次多出了编译和链接的过程，性能肯定会受到影响；而python并不是每次都需要转换字节码，解释器在转换之前会判断代码文件的修改时间是否与上一次转换后的字节码pyc文件的修改时间一致，若不一致才会重新转换。</li><li>由于不用关心程序的编译和库的链接等问题，开发的工作也就更加轻松啦。</li><li>python代码与机器底层更远了，python程序更加易于移植，基本上无需改动就能在多平台上运行。</li></ol><p>​      在具体计算机上实现一种语言，首先要确定的是表示该语言语义解释的虚拟计算机，一个关键的问题是程序执行时的基本表示是实际计算机上的机器语言还是虚拟机的机器语言。这个问题决定了语言的实现。根据这个问题的回答，可以将程序设计语言划分为两大类：编译型语言和解释型语言。</p><ol><li>编译实现的语言，如：C、C++、Fortran、Pascal、Ada。由编译型语言编写的源程序需要经过编译,汇编和链接才能输出目标代码，然后由机器执行目标代码。目标代码是有机器指令组成，不能独立运行，因为源程序中可能使用了一些汇编程序不能解释引用的库函数，而库函数又不在源程序中，此时还需要链接程序完成外部引用和目标模板调用的链接任务，最后才能输出可执行代码。</li><li>解释型语言，解释器不产生目标机器代码，而是产生中间代码，这种中间代码与机器代码不同，中间代码的解释是由软件支持的，不能直接使用在硬件上。该软件解释器通常会导致执行效率较低，用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。和编译的程序不同的是, 解释程序的任务是逐一将源代码的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。对于解释型语言，需要一个专门的解释器来执行该程序，每条语句只有在执行是才能被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。</li><li>Java解释器，java很特殊，java是需要编译的，但是没有直接编译成机器语言，而是编译成字节码，然后在Java虚拟机上用解释的方式执行字节码。Python也使用了类似的方式，先将python编译成python字节码，然后由一个专门的python字节码解释器负责解释执行字节码。</li><li>python是一门解释语言，但是出于效率的考虑，提供了一种编译的方法。编译之后就得到pyc文件，存储了字节码。python这点和java很类似，但是java与python不同的是，python是一个解释型的语言，所以编译字节码不是一个强制的操作，事实上，编译是一个自动的过程，一般不会在意它的存在。编译成字节码可以节省加载模块的时间，提高效率。</li><li>除了效率之外，字节码的形式也增加了反向工程的难度，可以保护源代码。这个只是一定程度上的保护，反编译还是可以的。</li></ol><a id="more"></a><h1 id="2-python内部执行过程"><a href="#2-python内部执行过程" class="headerlink" title="2. python内部执行过程"></a>2. python内部执行过程</h1><h2 id="2-1-编译过程概述"><a href="#2-1-编译过程概述" class="headerlink" title="2.1. 编译过程概述"></a>2.1. 编译过程概述</h2><p>　　当我们执行Python代码的时候，在Python解释器用四个过程“拆解”我们的代码，最终被CPU执行返回给用户。</p><p>　　首先当用户键入代码交给Python处理的时候会先进行词法分析，例如用户键入关键字或者当输入关键字有误时，都会被词法分析所触发，不正确的代码将不会被执行。</p><p>　　下一步Python会进行语法分析，例如当”for i in test:”中，test后面的冒号如果被写为其他符号，代码依旧不会被执行。</p><p>　　下面进入最关键的过程，在执行Python前，Python会生成.pyc文件，这个文件就是字节码，如果我们不小心修改了字节码，Python下次重新编译该程序时会和其上次生成的字节码文件进行比较，如果不匹配则会将被修改过的字节码文件进行覆盖，以确保每次编译后字节码的准确性。</p><p>　　那么什么是字节码？字节码在Python虚拟机程序里对应的是PyCodeObject对象。.pyc文件是字节码在磁盘上的表现形式。简单来说就是在编译代码的过程中，首先会将代码中的函数、类等对象分类处理，然后生成字节码文件。有了字节码文件，CPU可以直接识别字节码文件进行处理，接着Python就可执行了。</p><h2 id="2-2-过程图解"><a href="#2-2-过程图解" class="headerlink" title="2.2. 过程图解"></a>2.2. 过程图解</h2><p><img src="/images/blog/2021/PVM.jpg" alt></p><h2 id="2-3-编译字节码"><a href="#2-3-编译字节码" class="headerlink" title="2.3. 编译字节码"></a>2.3. 编译字节码</h2><p>　　Python中有一个内置函数compile()，可以将源文件编译成codeobject，首先看这个函数的说明：</p><p>　　compile(…) compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object</p><p>　　参数1：源文件的内容字符串</p><p>　　参数2：源文件名称</p><p>　　参数3：exec-编译module，single-编译一个声明，eval-编译一个表达式 一般使用前三个参数就够了</p><p>　　使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#src_file.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#some function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d=<span class="number">0</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    c=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">a=<span class="number">9</span></span><br><span class="line"></span><br><span class="line">b=<span class="number">8</span></span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=open(<span class="string">'src_file.py'</span>,<span class="string">'r'</span>).read()    <span class="comment">#命令行模式中打开源文件进行编译</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co=compile(a,<span class="string">'src_file'</span>,<span class="string">'exec'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(co)</span><br><span class="line"></span><br><span class="line">&lt;type <span class="string">'code'</span>&gt;    <span class="comment">#编译出了codeobject对象</span></span><br></pre></td></tr></table></figure><h2 id="2-4-codeobject对象的属性"><a href="#2-4-codeobject对象的属性" class="headerlink" title="2.4. codeobject对象的属性"></a>2.4. codeobject对象的属性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_names    <span class="comment">#所有的符号名称</span></span><br><span class="line">(<span class="string">'f'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_name    <span class="comment">#模块名、函数名、类名</span></span><br><span class="line">&lt;module&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_consts    <span class="comment">#常量集合、函数f和两个int常量a,b，d</span></span><br><span class="line">(0, &lt;code object f at 0xb7273b18, file <span class="string">"src_file"</span>, line 2&gt;, 9, 8, None)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_consts[1].co_varnames    <span class="comment">#可以看到f函数也是一个codeobject,打印f中的局部变量</span></span><br><span class="line">(<span class="string">'c'</span>,)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_code    <span class="comment">#字节码指令</span></span><br><span class="line">dZdZdZedS</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_consts[1].co_firstlineno    <span class="comment">#代码块在文件中的起始行号</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_stacksize    <span class="comment">#代码栈大小</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> co.co_filename    <span class="comment">#文件名</span></span><br><span class="line">src_file    <span class="comment">#模块名、函数名、类名</span></span><br></pre></td></tr></table></figure><p>codeobject的co_code代表了字节码，这个字节码有什么含义？我们可以使用dis模块进行python的反编译：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(co)</span><br></pre></td></tr></table></figure><p>　从反编译的结果来看，python字节码其实是模仿的x86的汇编，将代码编译成一条一条的指令交给一个虚拟的cpu去执行。</p><ul><li>第一列：行号</li><li>第二列：指令在代码块中的偏移量</li><li>第三列：指令</li><li>第四列：操作数</li><li>第五列：操作数说明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">dis.dis(co)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; output</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span>        <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">          <span class="number">3</span> LOAD_CONST               <span class="number">1</span> (&lt;code object f at <span class="number">0xb7273b18</span>, file <span class="string">"src_file"</span>, line <span class="number">2</span>&gt;)</span><br><span class="line"></span><br><span class="line">          <span class="number">6</span> MAKE_FUNCTION            <span class="number">1</span></span><br><span class="line"></span><br><span class="line">          <span class="number">9</span> STORE_NAME               <span class="number">0</span> (f)</span><br><span class="line"></span><br><span class="line"> <span class="number">5</span>        <span class="number">12</span> LOAD_CONST              <span class="number">2</span> (<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">          <span class="number">15</span> STORE_NAME              <span class="number">1</span> (a)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="number">6</span>        <span class="number">18</span> LOAD_CONST              <span class="number">3</span> (<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">          <span class="number">21</span> STORE_NAME              <span class="number">2</span> (b)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="number">7</span>        <span class="number">24</span> LOAD_NAME               <span class="number">0</span> (f)</span><br><span class="line"></span><br><span class="line">          <span class="number">27</span> CALL_FUNCTION           <span class="number">0</span></span><br><span class="line"></span><br><span class="line">          <span class="number">30</span> POP_TOP            </span><br><span class="line"></span><br><span class="line">          <span class="number">31</span> LOAD_CONST              <span class="number">4</span> (None)</span><br><span class="line"></span><br><span class="line">          <span class="number">34</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/helloxiaozhe/article/details/78104975&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python编译过程和执行原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;

&lt;h1 id=&quot;1-python执行原理&quot;&gt;&lt;a href=&quot;#1-python执行原理&quot; class=&quot;headerlink&quot; title=&quot;1. python执行原理&quot;&gt;&lt;/a&gt;1. python执行原理&lt;/h1&gt;&lt;p&gt;这里的解释执行是相对于编译执行而言的。我们都知道，使用C/C++之类的编译性语言编写的程序，是需要从源文件转换成计算机使用的机器语言，经过链接器链接之后形成了二进制的可执行文件。运行该程序的时候，就可以把二进制程序从硬盘载入到内存中并运行。&lt;/p&gt;
&lt;p&gt;但是对于Python而言，python源码不需要编译成二进制代码，它可以直接从源代码运行程序。当我们运行python文件程序的时候，python解释器将源代码转换为字节码，然后再由python解释器来执行这些字节码。这样，python就不用担心程序的编译,库的链接加载等问题了。&lt;/p&gt;
&lt;p&gt;对于python解释语言，有以下3方面的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次运行都要进行转换成字节码，然后再有虚拟机把字节码转换成机器语言，最后才能在硬件上运行。与编译性语言相比，每次多出了编译和链接的过程，性能肯定会受到影响；而python并不是每次都需要转换字节码，解释器在转换之前会判断代码文件的修改时间是否与上一次转换后的字节码pyc文件的修改时间一致，若不一致才会重新转换。&lt;/li&gt;
&lt;li&gt;由于不用关心程序的编译和库的链接等问题，开发的工作也就更加轻松啦。&lt;/li&gt;
&lt;li&gt;python代码与机器底层更远了，python程序更加易于移植，基本上无需改动就能在多平台上运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​      在具体计算机上实现一种语言，首先要确定的是表示该语言语义解释的虚拟计算机，一个关键的问题是程序执行时的基本表示是实际计算机上的机器语言还是虚拟机的机器语言。这个问题决定了语言的实现。根据这个问题的回答，可以将程序设计语言划分为两大类：编译型语言和解释型语言。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译实现的语言，如：C、C++、Fortran、Pascal、Ada。由编译型语言编写的源程序需要经过编译,汇编和链接才能输出目标代码，然后由机器执行目标代码。目标代码是有机器指令组成，不能独立运行，因为源程序中可能使用了一些汇编程序不能解释引用的库函数，而库函数又不在源程序中，此时还需要链接程序完成外部引用和目标模板调用的链接任务，最后才能输出可执行代码。&lt;/li&gt;
&lt;li&gt;解释型语言，解释器不产生目标机器代码，而是产生中间代码，这种中间代码与机器代码不同，中间代码的解释是由软件支持的，不能直接使用在硬件上。该软件解释器通常会导致执行效率较低，用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。和编译的程序不同的是, 解释程序的任务是逐一将源代码的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。对于解释型语言，需要一个专门的解释器来执行该程序，每条语句只有在执行是才能被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。&lt;/li&gt;
&lt;li&gt;Java解释器，java很特殊，java是需要编译的，但是没有直接编译成机器语言，而是编译成字节码，然后在Java虚拟机上用解释的方式执行字节码。Python也使用了类似的方式，先将python编译成python字节码，然后由一个专门的python字节码解释器负责解释执行字节码。&lt;/li&gt;
&lt;li&gt;python是一门解释语言，但是出于效率的考虑，提供了一种编译的方法。编译之后就得到pyc文件，存储了字节码。python这点和java很类似，但是java与python不同的是，python是一个解释型的语言，所以编译字节码不是一个强制的操作，事实上，编译是一个自动的过程，一般不会在意它的存在。编译成字节码可以节省加载模块的时间，提高效率。&lt;/li&gt;
&lt;li&gt;除了效率之外，字节码的形式也增加了反向工程的难度，可以保护源代码。这个只是一定程度上的保护，反编译还是可以的。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
    
      <category term="python" scheme="http://haokailong.top/tags/python/"/>
    
      <category term="PVM" scheme="http://haokailong.top/tags/PVM/"/>
    
      <category term="执行原理" scheme="http://haokailong.top/tags/%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译" scheme="http://haokailong.top/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="解释" scheme="http://haokailong.top/tags/%E8%A7%A3%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>conda添加源</title>
    <link href="http://haokailong.top/2021/03/15/conda%E6%B7%BB%E5%8A%A0%E6%BA%90/"/>
    <id>http://haokailong.top/2021/03/15/conda添加源/</id>
    <published>2021-03-15T07:08:52.000Z</published>
    <updated>2021-03-15T12:28:11.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-通过命令行"><a href="#1-通过命令行" class="headerlink" title="1. 通过命令行"></a>1. 通过命令行</h1><p>添加清华源，命令行中直接输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置搜索时显示通道地址</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><p>如果还需要<strong>pytorch</strong>，就添加pytorch镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br></pre></td></tr></table></figure><p>添加中科大源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"> </span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="2-通过配置文件"><a href="#2-通过配置文件" class="headerlink" title="2. 通过配置文件"></a>2. 通过配置文件</h1><p>在Linux系统中，可以直接将以下配置写入<code>~/.condarc</code>中：</p><p><strong>使用<a href="https://mirrors.bfsu.edu.cn/help/anaconda/" target="_blank" rel="noopener">BFSU的镜像：</a></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line"><span class="attr">  - https:</span><span class="string">//mirrors.bfsu.edu.cn/anaconda/pkgs/main</span></span><br><span class="line"><span class="attr">  - https:</span><span class="string">//mirrors.bfsu.edu.cn/anaconda/pkgs/r</span></span><br><span class="line"><span class="attr">  - https:</span><span class="string">//mirrors.bfsu.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line"><span class="attr">  conda-forge:</span> <span class="attr">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line"><span class="attr">  msys2:</span> <span class="attr">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line"><span class="attr">  bioconda:</span> <span class="attr">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line"><span class="attr">  menpo:</span> <span class="attr">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line"><span class="attr">  pytorch:</span> <span class="attr">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line"><span class="attr">  simpleitk:</span> <span class="attr">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br></pre></td></tr></table></figure><h1 id="3-删源"><a href="#3-删源" class="headerlink" title="3. 删源"></a>3. 删源</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-通过命令行&quot;&gt;&lt;a href=&quot;#1-通过命令行&quot; class=&quot;headerlink&quot; title=&quot;1. 通过命令行&quot;&gt;&lt;/a&gt;1. 通过命令行&lt;/h1&gt;&lt;p&gt;添加清华源，命令行中直接输入以下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 设置搜索时显示通道地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; show_channel_urls yes&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果还需要&lt;strong&gt;pytorch&lt;/strong&gt;，就添加pytorch镜像：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;添加中科大源：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda config --&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; show_channel_urls yes&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="conda" scheme="http://haokailong.top/tags/conda/"/>
    
      <category term="tsinghua" scheme="http://haokailong.top/tags/tsinghua/"/>
    
  </entry>
  
  <entry>
    <title>C++二维数组传参</title>
    <link href="http://haokailong.top/2021/03/14/C-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82/"/>
    <id>http://haokailong.top/2021/03/14/C-二维数组传参/</id>
    <published>2021-03-14T04:59:37.000Z</published>
    <updated>2021-03-15T06:25:39.794Z</updated>
    
    <content type="html"><![CDATA[<p>在LeetCode上，总是需要用到对不固定维度的二维数组传参，传参有多种方式，这里进行一下探究和复习。</p><h1 id="1-一级指针"><a href="#1-一级指针" class="headerlink" title="1. 一级指针"></a>1. 一级指针</h1><p>高维数组在栈中存放时内存是连续的，也可以看作一维数组，并手动计算索引对应的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(dp + i * n + j) &lt;&lt; <span class="string">' '</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> dp[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">dp[i][j] = i + j;</span><br><span class="line"> </span><br><span class="line">func((<span class="keyword">int</span>*)dp, m, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 </span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="2-二级指针"><a href="#2-二级指针" class="headerlink" title="2. 二级指针"></a>2. 二级指针</h1><p>使用<strong>new</strong>在堆中申请空间，然后传参。即指针的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> **dp, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[i][j] &lt;&lt; <span class="string">' '</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> **dp = <span class="keyword">new</span> <span class="keyword">int</span>*[m];  <span class="comment">// 在堆中申请空间 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">dp[i][j] = i + j;</span><br><span class="line"> </span><br><span class="line">func(dp, m, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 </span><br><span class="line">1 2 3 </span><br><span class="line">2 3 4</span><br></pre></td></tr></table></figure><p>这种方式申请的内存不在栈中，而是在堆中。而且，<strong><em>由于多次申请了内存，不同的行间内存空间是不连续的</em></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在LeetCode上，总是需要用到对不固定维度的二维数组传参，传参有多种方式，这里进行一下探究和复习。&lt;/p&gt;
&lt;h1 id=&quot;1-一级指针&quot;&gt;&lt;a href=&quot;#1-一级指针&quot; class=&quot;headerlink&quot; title=&quot;1. 一级指针&quot;&gt;&lt;/a&gt;1. 一级指针&lt;/h1&gt;&lt;p&gt;高维数组在栈中存放时内存是连续的，也可以看作一维数组，并手动计算索引对应的地址。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *dp, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;n;++j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *(dp + i * n + j) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m, n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dp[m][n];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;++i) &lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;n;++j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dp[i][j] = i + j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)dp, m, n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 1 2 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 2 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://haokailong.top/categories/Algorithms/"/>
    
      <category term="LeetCode" scheme="http://haokailong.top/categories/Algorithms/LeetCode/"/>
    
    
      <category term="C++" scheme="http://haokailong.top/tags/C/"/>
    
      <category term="LeetCode" scheme="http://haokailong.top/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://haokailong.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>pandas.merge()函数</title>
    <link href="http://haokailong.top/2021/03/13/pandas-merge-%E5%87%BD%E6%95%B0/"/>
    <id>http://haokailong.top/2021/03/13/pandas-merge-函数/</id>
    <published>2021-03-13T12:29:36.000Z</published>
    <updated>2021-03-13T13:04:18.760Z</updated>
    
    <content type="html"><![CDATA[<p>在使用pandas时，合并两个DataFrame，可以采用不同的连接方法，类似于数据库中表格的join操作，对不同的操作进行实验尝试。</p><h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pandas</span><br><span class="line">&gt;&gt;&gt; sheet1 = pandas.DataFrame(&#123;<span class="string">"ID"</span>:[<span class="string">"A01"</span>, <span class="string">"B01"</span>, <span class="string">"A02"</span>], <span class="string">"name"</span>:[<span class="string">"Bob"</span>, <span class="string">"Mary"</span>, <span class="string">"Bob"</span>], <span class="string">"age"</span>: [20, 22, 35]&#125;)</span><br><span class="line">&gt;&gt;&gt; sheet1</span><br><span class="line">    ID  name  age</span><br><span class="line">0  A01   Bob   20</span><br><span class="line">1  B01  Mary   22</span><br><span class="line">2  A02   Bob   35</span><br><span class="line">&gt;&gt;&gt; sheet2 = pandas.DataFrame(&#123;<span class="string">"name"</span>: [<span class="string">"Bob"</span>, <span class="string">"Mary"</span>, <span class="string">"Jack"</span>], <span class="string">"country"</span>: [<span class="string">"US"</span>, <span class="string">"Singapore"</span>, <span class="string">"China"</span>]&#125;)</span><br><span class="line">&gt;&gt;&gt; sheet2</span><br><span class="line">   name    country</span><br><span class="line">0   Bob         US</span><br><span class="line">1  Mary  Singapore</span><br><span class="line">2  Jack      China</span><br></pre></td></tr></table></figure><h1 id="1-left"><a href="#1-left" class="headerlink" title="1. left"></a>1. left</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet1.merge(sheet2, how=<span class="string">"left"</span>, on=<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    ID  name  age    country</span><br><span class="line">0  A01   Bob   20         US</span><br><span class="line">1  B01  Mary   22  Singapore</span><br><span class="line">2  A02   Bob   35         US</span><br></pre></td></tr></table></figure><p>按照左表的”name”将两个sheet的属性合并。</p><a id="more"></a><h1 id="2-right"><a href="#2-right" class="headerlink" title="2. right"></a>2. right</h1><p>同样是按照”name”合并，但是如果指定合并方式为”right”的话，则会保留右侧的所有“name”，如果一个”name”可以匹配到多个左表中记录，则合并后对应同样数量的多个记录。对于没有匹配的”name”值，补”NaN”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet1.merge(sheet2, how=<span class="string">"right"</span>, on=<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    ID  name   age    country</span><br><span class="line">0  A01   Bob  20.0         US</span><br><span class="line">1  A02   Bob  35.0         US</span><br><span class="line">2  B01  Mary  22.0  Singapore</span><br><span class="line">3  NaN  Jack   NaN      China</span><br></pre></td></tr></table></figure><h1 id="3-inner"><a href="#3-inner" class="headerlink" title="3. inner"></a>3. inner</h1><p>使用inner合并，是取两张表的公共部分，即取交集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet1.merge(sheet2, how=<span class="string">"inner"</span>, on=<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    ID  name  age    country</span><br><span class="line">0  A01   Bob   20         US</span><br><span class="line">1  A02   Bob   35         US</span><br><span class="line">2  B01  Mary   22  Singapore</span><br></pre></td></tr></table></figure><p>由于在给出的例子中，左表中的name有”Bob”，“Mary”，均在右表中，所以合并结果与left合并完全相同。</p><h1 id="4-outer"><a href="#4-outer" class="headerlink" title="4. outer"></a>4. outer</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet1.merge(sheet2, how=<span class="string">"outer"</span>, on=<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    ID  name   age    country</span><br><span class="line">0  A01   Bob  20.0         US</span><br><span class="line">1  A02   Bob  35.0         US</span><br><span class="line">2  B01  Mary  22.0  Singapore</span><br><span class="line">3  NaN  Jack   NaN      China</span><br></pre></td></tr></table></figure><p>使用outer合并，是取两个表的key的并集，在举的例子里，结果与right合并完全相同。</p><h1 id="5-cross"><a href="#5-cross" class="headerlink" title="5. cross"></a>5. cross</h1><p>笛卡尔积，不常使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用pandas时，合并两个DataFrame，可以采用不同的连接方法，类似于数据库中表格的join操作，对不同的操作进行实验尝试。&lt;/p&gt;
&lt;h1 id=&quot;建表&quot;&gt;&lt;a href=&quot;#建表&quot; class=&quot;headerlink&quot; title=&quot;建表&quot;&gt;&lt;/a&gt;建表&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import pandas&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; sheet1 = pandas.DataFrame(&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;ID&quot;&lt;/span&gt;:[&lt;span class=&quot;string&quot;&gt;&quot;A01&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;B01&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;A02&quot;&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:[&lt;span class=&quot;string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;: [20, 22, 35]&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; sheet1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ID  name  age&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0  A01   Bob   20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1  B01  Mary   22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2  A02   Bob   35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; sheet2 = pandas.DataFrame(&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Jack&quot;&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&quot;country&quot;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&quot;US&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Singapore&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;China&quot;&lt;/span&gt;]&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; sheet2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   name    country&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0   Bob         US&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1  Mary  Singapore&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2  Jack      China&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;1-left&quot;&gt;&lt;a href=&quot;#1-left&quot; class=&quot;headerlink&quot; title=&quot;1. left&quot;&gt;&lt;/a&gt;1. left&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sheet1.merge(sheet2, how=&lt;span class=&quot;string&quot;&gt;&quot;left&quot;&lt;/span&gt;, on=&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    ID  name  age    country&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0  A01   Bob   20         US&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1  B01  Mary   22  Singapore&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2  A02   Bob   35         US&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;按照左表的”name”将两个sheet的属性合并。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="http://haokailong.top/categories/Others/"/>
    
      <category term="Tool" scheme="http://haokailong.top/categories/Others/Tool/"/>
    
    
      <category term="pandas" scheme="http://haokailong.top/tags/pandas/"/>
    
      <category term="merge" scheme="http://haokailong.top/tags/merge/"/>
    
      <category term="DataFrame" scheme="http://haokailong.top/tags/DataFrame/"/>
    
  </entry>
  
  <entry>
    <title>二分类中softmax对比sigmoid</title>
    <link href="http://haokailong.top/2021/03/12/%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B8%ADsoftmax%E5%AF%B9%E6%AF%94sigmoid/"/>
    <id>http://haokailong.top/2021/03/12/二分类中softmax对比sigmoid/</id>
    <published>2021-03-12T13:29:51.000Z</published>
    <updated>2021-03-12T15:04:21.908Z</updated>
    
    <content type="html"><![CDATA[<p>题外话：在Pycharm中<code>Ctrl+左键</code>就可以跳转到源码！用了这么多年竟然都不知道！😓</p><blockquote><p>本文引用自：<a href="https://www.aiuai.cn/aifarm679.html" target="_blank" rel="noopener">https://www.aiuai.cn/aifarm679.html</a></p></blockquote><h1 id="1-理论分析"><a href="#1-理论分析" class="headerlink" title="1. 理论分析"></a>1. 理论分析</h1><p>[1] Sigmoid</p><script type="math/tex; mode=display">\begin{equation} \begin{cases} p(y=1|x) = \frac{1}{1 + e ^{-\theta ^ T x}} \\ p(y=0|x) = 1 - p(y=1|x) = \frac{e ^{-\theta ^ T x}}{1 + e ^{-\theta ^ T x}} \end{cases} \end{equation}</script><p>[2] Softmax</p><script type="math/tex; mode=display">\begin{equation} \begin{cases} p(y=0|x) = \frac{e ^{\theta _0^T x} }{e ^{\theta _0^T x} + e ^{\theta _1^T x} } = \frac{e ^{(\theta _0^T - \theta _1^T)x} }{1 + e ^{(\theta _0^T - \theta _1^T) x} } \\ p(y=1|x) = 1 - p(y=0|x) \end{cases} \end{equation}</script><p>令 $\beta = -(\theta_0^T - \theta _1^T)$，则有：</p><script type="math/tex; mode=display">\begin{equation} \begin{cases} p(y=1|x) = \frac{1}{1 + e ^{-\beta ^ T x}} \\ p(y=0|x) = \frac{e ^{-\beta ^ T x}}{1 + e ^{-\beta ^ T x}} \end{cases} \end{equation}</script><p>可见，此时，Softmax 与 Sigmoid 二者理论公式的等价性.</p><h1 id="2-基于Keras的实验对比"><a href="#2-基于Keras的实验对比" class="headerlink" title="2. 基于Keras的实验对比"></a>2. 基于Keras的实验对比</h1><a id="more"></a><p>以猫狗分类的数据集为例，采用在 ImageNet 上预训练的 Xception 模型导出的特征.( <strong>复制于</strong> <a href="https://gist.github.com/ypwhs/6905ebbda99d04621f9fc00417657ae2" target="_blank" rel="noopener">ypwhs/sigmoid_and_softmax.ipynb</a> 中的代码. )</p><blockquote><p><a href="https://github.com/ypwhs/dogs_vs_cats/releases/download/gap/gap_Xception.h5" target="_blank" rel="noopener">gap_Xception.h5</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">20180520</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line"><span class="comment">#      加载猫狗分类的特征数据</span></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line"><span class="keyword">with</span> h5py.File(<span class="string">"gap_Xception.h5"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> h:</span><br><span class="line">    X = np.array(h[<span class="string">'train'</span>])</span><br><span class="line">    y = np.array(h[<span class="string">'label'</span>])</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">y_train_softmax = to_categorical(y_train) <span class="comment"># ont-hot</span></span><br><span class="line">y_test_softmax = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line"><span class="comment">#           Softmax</span></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line"><span class="comment"># loss: Softmax Cross Entropy Loss</span></span><br><span class="line">input_tensor = Input(X.shape[<span class="number">1</span>:])</span><br><span class="line">x = input_tensor</span><br><span class="line">x = Dropout(<span class="number">0.5</span>)(x)</span><br><span class="line">softmax = Dense(<span class="number">2</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">x = softmax(x)</span><br><span class="line">model = Model(input_tensor, x)</span><br><span class="line">model.compile(optimizer=SGD(<span class="number">1e-3</span>),  <span class="comment"># lr = 1e-3</span></span><br><span class="line">              loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">softmax_weights, softmax_bias = softmax.get_weights()</span><br><span class="line"></span><br><span class="line">history_softmax = model.fit(X_train, y_train_softmax, batch_size=<span class="number">128</span>, epochs=<span class="number">5</span>,</span><br><span class="line">                            validation_data=(X_test, y_test_softmax))</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line"><span class="comment">#           Sigmoid</span></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line"><span class="comment"># loss: Binary(Sigmoid) Cross Entropy Loss</span></span><br><span class="line">np.random.seed(<span class="number">20180520</span>)</span><br><span class="line">input_tensor = Input(X.shape[<span class="number">1</span>:])</span><br><span class="line">x = input_tensor</span><br><span class="line">x = Dropout(<span class="number">0.5</span>)(x)</span><br><span class="line">sigmoid = Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>)</span><br><span class="line">x = sigmoid(x)</span><br><span class="line">model = Model(input_tensor, x)</span><br><span class="line">model.compile(optimizer=SGD(<span class="number">2e-3</span>),  <span class="comment"># lr = 2e-3</span></span><br><span class="line">              loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sigmoid 权重初始化为 Softmax 的权重计算差值</span></span><br><span class="line"><span class="comment"># beta = sigmoid weights</span></span><br><span class="line">beta = -(softmax_weights[:,<span class="number">0</span>] - softmax_weights[:,<span class="number">1</span>]).reshape((<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">sigmoid.set_weights([beta, np.zeros(<span class="number">1</span>)]) <span class="comment"># set beta to sigmoid weights</span></span><br><span class="line"></span><br><span class="line">history_sigmoid = model.fit(X_train, y_train, batch_size=<span class="number">128</span>, epochs=<span class="number">5</span>, validation_data=(X_test, y_test))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line"><span class="comment">#           Sigmoid</span></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line">input_tensor = Input(X.shape[<span class="number">1</span>:])</span><br><span class="line">x = input_tensor</span><br><span class="line">x = Dropout(<span class="number">0.5</span>)(x)</span><br><span class="line">sigmoid = Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>)</span><br><span class="line">x = sigmoid(x)</span><br><span class="line">model = Model(input_tensor, x)</span><br><span class="line">model.compile(optimizer=SGD(<span class="number">2e-3</span>),  <span class="comment"># lr = 2e-3</span></span><br><span class="line">              loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># random init Sigmoid weights</span></span><br><span class="line"><span class="comment"># 随机初始化 Sigmoid 权重</span></span><br><span class="line">history_sigmoid_2 = model.fit(X_train, y_train, batch_size=<span class="number">128</span>, epochs=<span class="number">5</span>, validation_data=(X_test, y_test))</span><br></pre></td></tr></table></figure><p>训练过程输出：</p><p><strong>Softmax</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Train on 20000 samples, validate on 5000 samples</span><br><span class="line">Epoch 1/5</span><br><span class="line">20000/20000 [==============================] - 1s 68us/step - loss: 0.4711 - acc: 0.8535 - val_loss: 0.3765 - val_acc: 0.9642</span><br><span class="line">Epoch 2/5</span><br><span class="line">20000/20000 [==============================] - 0s 13us/step - loss: 0.3338 - acc: 0.9486 - val_loss: 0.2825 - val_acc: 0.9816</span><br><span class="line">Epoch 3/5</span><br><span class="line">20000/20000 [==============================] - 0s 11us/step - loss: 0.2594 - acc: 0.9726 - val_loss: 0.2279 - val_acc: 0.9858</span><br><span class="line">Epoch 4/5</span><br><span class="line">20000/20000 [==============================] - 0s 11us/step - loss: 0.2160 - acc: 0.9799 - val_loss: 0.1923 - val_acc: 0.9866</span><br><span class="line">Epoch 5/5</span><br><span class="line">20000/20000 [==============================] - 0s 13us/step - loss: 0.1860 - acc: 0.9825 - val_loss: 0.1677 - val_acc: 0.9868</span><br></pre></td></tr></table></figure><p><strong>Sigmoid With Softmax Weights</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Train on 20000 samples, validate on 5000 samples</span><br><span class="line">Epoch 1/5</span><br><span class="line">20000/20000 [==============================] - 0s 18us/step - loss: 0.4706 - acc: 0.8544 - val_loss: 0.3766 - val_acc: 0.9644</span><br><span class="line">Epoch 2/5</span><br><span class="line">20000/20000 [==============================] - 0s 12us/step - loss: 0.3346 - acc: 0.9476 - val_loss: 0.2824 - val_acc: 0.9816</span><br><span class="line">Epoch 3/5</span><br><span class="line">20000/20000 [==============================] - 0s 14us/step - loss: 0.2613 - acc: 0.9709 - val_loss: 0.2275 - val_acc: 0.9860</span><br><span class="line">Epoch 4/5</span><br><span class="line">20000/20000 [==============================] - 0s 14us/step - loss: 0.2151 - acc: 0.9789 - val_loss: 0.1923 - val_acc: 0.9868</span><br><span class="line">Epoch 5/5</span><br><span class="line">20000/20000 [==============================] - 0s 11us/step - loss: 0.1857 - acc: 0.9825 - val_loss: 0.1676 - val_acc: 0.9872</span><br></pre></td></tr></table></figure><p><strong>Sigmoid With Random Init Weight</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Train on 20000 samples, validate on 5000 samples</span><br><span class="line">Epoch 1/5</span><br><span class="line">20000/20000 [==============================] - 0s 18us/step - loss: 0.5690 - acc: 0.7607 - val_loss: 0.4415 - val_acc: 0.9718</span><br><span class="line">Epoch 2/5</span><br><span class="line">20000/20000 [==============================] - 0s 11us/step - loss: 0.3753 - acc: 0.9576 - val_loss: 0.3151 - val_acc: 0.9852</span><br><span class="line">Epoch 3/5</span><br><span class="line">20000/20000 [==============================] - 0s 12us/step - loss: 0.2819 - acc: 0.9814 - val_loss: 0.2464 - val_acc: 0.9878</span><br><span class="line">Epoch 4/5</span><br><span class="line">20000/20000 [==============================] - 0s 12us/step - loss: 0.2267 - acc: 0.9858 - val_loss: 0.2042 - val_acc: 0.9882</span><br><span class="line">Epoch 5/5</span><br><span class="line">20000/20000 [==============================] - 0s 11us/step - loss: 0.1921 - acc: 0.9872 - val_loss: 0.1759 - val_acc: 0.9882</span><br></pre></td></tr></table></figure><h3 id="2-1-训练-loss-曲线变化情况对比"><a href="#2-1-训练-loss-曲线变化情况对比" class="headerlink" title="2.1 训练 loss 曲线变化情况对比"></a>2.1 训练 loss 曲线变化情况对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(history_sigmoid.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history_softmax.history[<span class="string">'loss'</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(history_sigmoid.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.plot(history_softmax.history[<span class="string">'val_loss'</span>])</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">'sigmoid_loss'</span>, <span class="string">'softmax_loss'</span>, </span><br><span class="line">            <span class="string">'sigmoid_val_loss'</span>, <span class="string">'softmax_val_loss'</span>], loc=<span class="string">'upper right'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/blog/2021/sigmoid_softmax_loss.jpg" alt></p><p>从图中可知，Sigmoid 和 Softmax 的训练曲线几乎完全重合.</p><h3 id="2-2-Loss-差值可视化对比"><a href="#2-2-Loss-差值可视化对比" class="headerlink" title="2.2 Loss 差值可视化对比"></a>2.2 Loss 差值可视化对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(np.array(history_sigmoid.history[<span class="string">'val_loss'</span>]) - np.array(history_softmax.history[<span class="string">'val_loss'</span>]))</span><br><span class="line">plt.plot(np.array(history_sigmoid.history[<span class="string">'val_loss'</span>]) - np.array(history_sigmoid_2.history[<span class="string">'val_loss'</span>]))</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">'sigmoid_softmax_beta_gap'</span>, <span class="string">'sigmoid_random_weight_gap'</span>], loc=<span class="string">'upper right'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/blog/2021/loss_difference.jpg" alt></p><p>图中<strong>蓝色曲线</strong>几乎一直是 0，其表示 Sigmoid 和 Softmax 训练的模型的 loss 差异性很小. 但<strong>黄色曲线</strong> 的差值相对就较大，其采用的随机初始化 Sigmoid 权重值，影响了训练过程中的 loss 曲线的变化.</p><p>也就是说，如果设置了正确的 beta 值，Sigmoid 与 Softmax 的效果可认为是等价的.</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>对于二分类问题，</p><p>[1] - Sigmoid 与 Softmax 完全等价.</p><p>[2] - Sigmoid 与 Softmax 分类器的权值可以相互转换.</p><p>[3] - Softmax 的学习率是 Sigmoid 学习率的2倍. (如：1e-3与2e-3)</p><p>[4] - Softmax 会比 Sigmoid 浪费 2 倍的权值空间(权重参数是两倍).</p><hr color="blue"><p><strong>PS: 根据任务需要，手动修改损失函数，是一项必要的技能。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题外话：在Pycharm中&lt;code&gt;Ctrl+左键&lt;/code&gt;就可以跳转到源码！用了这么多年竟然都不知道！😓&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文引用自：&lt;a href=&quot;https://www.aiuai.cn/aifarm679.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.aiuai.cn/aifarm679.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-理论分析&quot;&gt;&lt;a href=&quot;#1-理论分析&quot; class=&quot;headerlink&quot; title=&quot;1. 理论分析&quot;&gt;&lt;/a&gt;1. 理论分析&lt;/h1&gt;&lt;p&gt;[1] Sigmoid&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\begin{equation} \begin{cases} p(y=1|x) = \frac{1}{1 + e ^{-\theta ^ T x}} \\ p(y=0|x) = 1 - p(y=1|x) = \frac{e ^{-\theta ^ T x}}{1 + e ^{-\theta ^ T x}} \end{cases} \end{equation}&lt;/script&gt;&lt;p&gt;[2] Softmax&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\begin{equation} \begin{cases} p(y=0|x) = \frac{e ^{\theta _0^T x} }{e ^{\theta _0^T x} + e ^{\theta _1^T x} } = \frac{e ^{(\theta _0^T - \theta _1^T)x} }{1 + e ^{(\theta _0^T - \theta _1^T) x} } \\ p(y=1|x) = 1 - p(y=0|x) \end{cases} \end{equation}&lt;/script&gt;&lt;p&gt;令 $\beta = -(\theta_0^T - \theta _1^T)$，则有：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{equation} \begin{cases} p(y=1|x) = \frac{1}{1 + e ^{-\beta ^ T x}} \\ p(y=0|x) = \frac{e ^{-\beta ^ T x}}{1 + e ^{-\beta ^ T x}} \end{cases} \end{equation}&lt;/script&gt;&lt;p&gt;可见，此时，Softmax 与 Sigmoid 二者理论公式的等价性.&lt;/p&gt;
&lt;h1 id=&quot;2-基于Keras的实验对比&quot;&gt;&lt;a href=&quot;#2-基于Keras的实验对比&quot; class=&quot;headerlink&quot; title=&quot;2. 基于Keras的实验对比&quot;&gt;&lt;/a&gt;2. 基于Keras的实验对比&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Neural Networks" scheme="http://haokailong.top/categories/Neural-Networks/"/>
    
    
      <category term="pytorch" scheme="http://haokailong.top/tags/pytorch/"/>
    
      <category term="softmax" scheme="http://haokailong.top/tags/softmax/"/>
    
      <category term="sigmoid" scheme="http://haokailong.top/tags/sigmoid/"/>
    
      <category term="binary classification" scheme="http://haokailong.top/tags/binary-classification/"/>
    
  </entry>
  
  <entry>
    <title>The log-sum-exp trick</title>
    <link href="http://haokailong.top/2021/03/12/The-log-sum-exp-trick/"/>
    <id>http://haokailong.top/2021/03/12/The-log-sum-exp-trick/</id>
    <published>2021-03-12T12:18:42.000Z</published>
    <updated>2021-03-12T12:31:19.021Z</updated>
    
    <content type="html"><![CDATA[<p>在机器学习和神经网络中，$\log()$是一个常用的技巧。</p><p>例如，对于函数求导时，使用$\log()$可以简化计算，避免乘法法则。</p><script type="math/tex; mode=display">\frac{\partial}{\partial x} \log[f(x)g(x)] = \frac{\partial}{\partial x}f(x) + \frac{\partial}{\partial x} g(x).</script><h2 id="在softmax-函数中的运用"><a href="#在softmax-函数中的运用" class="headerlink" title="在softmax()函数中的运用"></a>在softmax()函数中的运用</h2><p>在softmax()函数中，按照以下公式，将得分转化为对应的概率：</p><script type="math/tex; mode=display">\frac{\exp(x_m)}{\sum_{i=1}^N \exp(x_n)}</script><p>如果分母过大，则很容易溢出，按照以下方式进行转化：</p><script type="math/tex; mode=display">y = \log \sum_{i=1}^n \exp(x_n) \\e^y = \sum_{i=1}^n\exp(x_n) \\e^y = e^c\sum_{i=1}^n\exp(x_n-c) \\y = c + \log \sum_{i=1}^n \exp(x_n-c)</script><p>如果设置$c = \max{x_1,…,x_n}$，则最大不超过1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在机器学习和神经网络中，$\log()$是一个常用的技巧。&lt;/p&gt;
&lt;p&gt;例如，对于函数求导时，使用$\log()$可以简化计算，避免乘法法则。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{\partial}{\part
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://haokailong.top/categories/Algorithms/"/>
    
    
      <category term="pytorch" scheme="http://haokailong.top/tags/pytorch/"/>
    
      <category term="log-sum-exp" scheme="http://haokailong.top/tags/log-sum-exp/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 84 递增栈</title>
    <link href="http://haokailong.top/2021/03/12/Leetcode-84-%E9%80%92%E5%A2%9E%E6%A0%88/"/>
    <id>http://haokailong.top/2021/03/12/Leetcode-84-递增栈/</id>
    <published>2021-03-12T04:30:19.000Z</published>
    <updated>2021-03-12T06:22:53.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol><li>最终矩形必然截断到某一高度</li><li>针对每一个高度，只需找到左右两侧的更高高度</li><li>递增栈的数据结构</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; slope &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=heights.size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (slope.back() &gt;= <span class="number">0</span> &amp;&amp; (i == heights.size() || heights[slope.back()] &gt;= heights[i])) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[slope.back()];</span><br><span class="line">        slope.pop_back();</span><br><span class="line">        ret = <span class="built_in">std</span>::max(ret, (i-slope.back()<span class="number">-1</span>)*height);</span><br><span class="line">      &#125;</span><br><span class="line">      slope.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>异常巧妙😲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;最终矩形必然截断到某一高度&lt;/li&gt;
&lt;li&gt;针对每一个高度，只需找到左右两侧的更高高度&lt;/li&gt;
&lt;li&gt;递增栈的数据结构&lt;/
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://haokailong.top/categories/Algorithms/"/>
    
      <category term="LeetCode" scheme="http://haokailong.top/categories/Algorithms/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://haokailong.top/tags/leetcode/"/>
    
      <category term="stack" scheme="http://haokailong.top/tags/stack/"/>
    
      <category term="递增栈" scheme="http://haokailong.top/tags/%E9%80%92%E5%A2%9E%E6%A0%88/"/>
    
  </entry>
  
</feed>
